// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/dexidp/dex/storage"
	"github.com/dexidp/dex/storage/ent/db/authcode"
	"github.com/dexidp/dex/storage/ent/db/authrequest"
	"github.com/dexidp/dex/storage/ent/db/connector"
	"github.com/dexidp/dex/storage/ent/db/devicerequest"
	"github.com/dexidp/dex/storage/ent/db/devicetoken"
	"github.com/dexidp/dex/storage/ent/db/keys"
	"github.com/dexidp/dex/storage/ent/db/oauth2client"
	"github.com/dexidp/dex/storage/ent/db/offlinesession"
	"github.com/dexidp/dex/storage/ent/db/password"
	"github.com/dexidp/dex/storage/ent/db/platformapprole"
	"github.com/dexidp/dex/storage/ent/db/platformfederatedidentity"
	"github.com/dexidp/dex/storage/ent/db/platformidentityroleassignment"
	"github.com/dexidp/dex/storage/ent/db/platformtoken"
	"github.com/dexidp/dex/storage/ent/db/platformuser"
	"github.com/dexidp/dex/storage/ent/db/platformuserroleassignment"
	"github.com/dexidp/dex/storage/ent/db/predicate"
	"github.com/dexidp/dex/storage/ent/db/refreshtoken"
	jose "github.com/go-jose/go-jose/v4"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthCode                       = "AuthCode"
	TypeAuthRequest                    = "AuthRequest"
	TypeConnector                      = "Connector"
	TypeDeviceRequest                  = "DeviceRequest"
	TypeDeviceToken                    = "DeviceToken"
	TypeKeys                           = "Keys"
	TypeOAuth2Client                   = "OAuth2Client"
	TypeOfflineSession                 = "OfflineSession"
	TypePassword                       = "Password"
	TypePlatformAppRole                = "PlatformAppRole"
	TypePlatformFederatedIdentity      = "PlatformFederatedIdentity"
	TypePlatformIdentityRoleAssignment = "PlatformIdentityRoleAssignment"
	TypePlatformToken                  = "PlatformToken"
	TypePlatformUser                   = "PlatformUser"
	TypePlatformUserRoleAssignment     = "PlatformUserRoleAssignment"
	TypeRefreshToken                   = "RefreshToken"
)

// AuthCodeMutation represents an operation that mutates the AuthCode nodes in the graph.
type AuthCodeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	client_id                 *string
	scopes                    *[]string
	appendscopes              []string
	nonce                     *string
	redirect_uri              *string
	claims_user_id            *string
	claims_username           *string
	claims_email              *string
	claims_email_verified     *bool
	claims_groups             *[]string
	appendclaims_groups       []string
	claims_preferred_username *string
	connector_id              *string
	connector_data            *[]byte
	expiry                    *time.Time
	code_challenge            *string
	code_challenge_method     *string
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*AuthCode, error)
	predicates                []predicate.AuthCode
}

var _ ent.Mutation = (*AuthCodeMutation)(nil)

// authcodeOption allows management of the mutation configuration using functional options.
type authcodeOption func(*AuthCodeMutation)

// newAuthCodeMutation creates new mutation for the AuthCode entity.
func newAuthCodeMutation(c config, op Op, opts ...authcodeOption) *AuthCodeMutation {
	m := &AuthCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthCodeID sets the ID field of the mutation.
func withAuthCodeID(id string) authcodeOption {
	return func(m *AuthCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthCode
		)
		m.oldValue = func(ctx context.Context) (*AuthCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthCode sets the old AuthCode of the mutation.
func withAuthCode(node *AuthCode) authcodeOption {
	return func(m *AuthCodeMutation) {
		m.oldValue = func(context.Context) (*AuthCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthCode entities.
func (m *AuthCodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthCodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthCodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *AuthCodeMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthCodeMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthCodeMutation) ResetClientID() {
	m.client_id = nil
}

// SetScopes sets the "scopes" field.
func (m *AuthCodeMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *AuthCodeMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *AuthCodeMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *AuthCodeMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *AuthCodeMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[authcode.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *AuthCodeMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[authcode.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *AuthCodeMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, authcode.FieldScopes)
}

// SetNonce sets the "nonce" field.
func (m *AuthCodeMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *AuthCodeMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *AuthCodeMutation) ResetNonce() {
	m.nonce = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AuthCodeMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AuthCodeMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AuthCodeMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetClaimsUserID sets the "claims_user_id" field.
func (m *AuthCodeMutation) SetClaimsUserID(s string) {
	m.claims_user_id = &s
}

// ClaimsUserID returns the value of the "claims_user_id" field in the mutation.
func (m *AuthCodeMutation) ClaimsUserID() (r string, exists bool) {
	v := m.claims_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUserID returns the old "claims_user_id" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUserID: %w", err)
	}
	return oldValue.ClaimsUserID, nil
}

// ResetClaimsUserID resets all changes to the "claims_user_id" field.
func (m *AuthCodeMutation) ResetClaimsUserID() {
	m.claims_user_id = nil
}

// SetClaimsUsername sets the "claims_username" field.
func (m *AuthCodeMutation) SetClaimsUsername(s string) {
	m.claims_username = &s
}

// ClaimsUsername returns the value of the "claims_username" field in the mutation.
func (m *AuthCodeMutation) ClaimsUsername() (r string, exists bool) {
	v := m.claims_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUsername returns the old "claims_username" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUsername: %w", err)
	}
	return oldValue.ClaimsUsername, nil
}

// ResetClaimsUsername resets all changes to the "claims_username" field.
func (m *AuthCodeMutation) ResetClaimsUsername() {
	m.claims_username = nil
}

// SetClaimsEmail sets the "claims_email" field.
func (m *AuthCodeMutation) SetClaimsEmail(s string) {
	m.claims_email = &s
}

// ClaimsEmail returns the value of the "claims_email" field in the mutation.
func (m *AuthCodeMutation) ClaimsEmail() (r string, exists bool) {
	v := m.claims_email
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmail returns the old "claims_email" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmail: %w", err)
	}
	return oldValue.ClaimsEmail, nil
}

// ResetClaimsEmail resets all changes to the "claims_email" field.
func (m *AuthCodeMutation) ResetClaimsEmail() {
	m.claims_email = nil
}

// SetClaimsEmailVerified sets the "claims_email_verified" field.
func (m *AuthCodeMutation) SetClaimsEmailVerified(b bool) {
	m.claims_email_verified = &b
}

// ClaimsEmailVerified returns the value of the "claims_email_verified" field in the mutation.
func (m *AuthCodeMutation) ClaimsEmailVerified() (r bool, exists bool) {
	v := m.claims_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmailVerified returns the old "claims_email_verified" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmailVerified: %w", err)
	}
	return oldValue.ClaimsEmailVerified, nil
}

// ResetClaimsEmailVerified resets all changes to the "claims_email_verified" field.
func (m *AuthCodeMutation) ResetClaimsEmailVerified() {
	m.claims_email_verified = nil
}

// SetClaimsGroups sets the "claims_groups" field.
func (m *AuthCodeMutation) SetClaimsGroups(s []string) {
	m.claims_groups = &s
	m.appendclaims_groups = nil
}

// ClaimsGroups returns the value of the "claims_groups" field in the mutation.
func (m *AuthCodeMutation) ClaimsGroups() (r []string, exists bool) {
	v := m.claims_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsGroups returns the old "claims_groups" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsGroups: %w", err)
	}
	return oldValue.ClaimsGroups, nil
}

// AppendClaimsGroups adds s to the "claims_groups" field.
func (m *AuthCodeMutation) AppendClaimsGroups(s []string) {
	m.appendclaims_groups = append(m.appendclaims_groups, s...)
}

// AppendedClaimsGroups returns the list of values that were appended to the "claims_groups" field in this mutation.
func (m *AuthCodeMutation) AppendedClaimsGroups() ([]string, bool) {
	if len(m.appendclaims_groups) == 0 {
		return nil, false
	}
	return m.appendclaims_groups, true
}

// ClearClaimsGroups clears the value of the "claims_groups" field.
func (m *AuthCodeMutation) ClearClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	m.clearedFields[authcode.FieldClaimsGroups] = struct{}{}
}

// ClaimsGroupsCleared returns if the "claims_groups" field was cleared in this mutation.
func (m *AuthCodeMutation) ClaimsGroupsCleared() bool {
	_, ok := m.clearedFields[authcode.FieldClaimsGroups]
	return ok
}

// ResetClaimsGroups resets all changes to the "claims_groups" field.
func (m *AuthCodeMutation) ResetClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	delete(m.clearedFields, authcode.FieldClaimsGroups)
}

// SetClaimsPreferredUsername sets the "claims_preferred_username" field.
func (m *AuthCodeMutation) SetClaimsPreferredUsername(s string) {
	m.claims_preferred_username = &s
}

// ClaimsPreferredUsername returns the value of the "claims_preferred_username" field in the mutation.
func (m *AuthCodeMutation) ClaimsPreferredUsername() (r string, exists bool) {
	v := m.claims_preferred_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsPreferredUsername returns the old "claims_preferred_username" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsPreferredUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsPreferredUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsPreferredUsername: %w", err)
	}
	return oldValue.ClaimsPreferredUsername, nil
}

// ResetClaimsPreferredUsername resets all changes to the "claims_preferred_username" field.
func (m *AuthCodeMutation) ResetClaimsPreferredUsername() {
	m.claims_preferred_username = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *AuthCodeMutation) SetConnectorID(s string) {
	m.connector_id = &s
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *AuthCodeMutation) ConnectorID() (r string, exists bool) {
	v := m.connector_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldConnectorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *AuthCodeMutation) ResetConnectorID() {
	m.connector_id = nil
}

// SetConnectorData sets the "connector_data" field.
func (m *AuthCodeMutation) SetConnectorData(b []byte) {
	m.connector_data = &b
}

// ConnectorData returns the value of the "connector_data" field in the mutation.
func (m *AuthCodeMutation) ConnectorData() (r []byte, exists bool) {
	v := m.connector_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorData returns the old "connector_data" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorData: %w", err)
	}
	return oldValue.ConnectorData, nil
}

// ClearConnectorData clears the value of the "connector_data" field.
func (m *AuthCodeMutation) ClearConnectorData() {
	m.connector_data = nil
	m.clearedFields[authcode.FieldConnectorData] = struct{}{}
}

// ConnectorDataCleared returns if the "connector_data" field was cleared in this mutation.
func (m *AuthCodeMutation) ConnectorDataCleared() bool {
	_, ok := m.clearedFields[authcode.FieldConnectorData]
	return ok
}

// ResetConnectorData resets all changes to the "connector_data" field.
func (m *AuthCodeMutation) ResetConnectorData() {
	m.connector_data = nil
	delete(m.clearedFields, authcode.FieldConnectorData)
}

// SetExpiry sets the "expiry" field.
func (m *AuthCodeMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *AuthCodeMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *AuthCodeMutation) ResetExpiry() {
	m.expiry = nil
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *AuthCodeMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *AuthCodeMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *AuthCodeMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *AuthCodeMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *AuthCodeMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *AuthCodeMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// Where appends a list predicates to the AuthCodeMutation builder.
func (m *AuthCodeMutation) Where(ps ...predicate.AuthCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthCode).
func (m *AuthCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthCodeMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.client_id != nil {
		fields = append(fields, authcode.FieldClientID)
	}
	if m.scopes != nil {
		fields = append(fields, authcode.FieldScopes)
	}
	if m.nonce != nil {
		fields = append(fields, authcode.FieldNonce)
	}
	if m.redirect_uri != nil {
		fields = append(fields, authcode.FieldRedirectURI)
	}
	if m.claims_user_id != nil {
		fields = append(fields, authcode.FieldClaimsUserID)
	}
	if m.claims_username != nil {
		fields = append(fields, authcode.FieldClaimsUsername)
	}
	if m.claims_email != nil {
		fields = append(fields, authcode.FieldClaimsEmail)
	}
	if m.claims_email_verified != nil {
		fields = append(fields, authcode.FieldClaimsEmailVerified)
	}
	if m.claims_groups != nil {
		fields = append(fields, authcode.FieldClaimsGroups)
	}
	if m.claims_preferred_username != nil {
		fields = append(fields, authcode.FieldClaimsPreferredUsername)
	}
	if m.connector_id != nil {
		fields = append(fields, authcode.FieldConnectorID)
	}
	if m.connector_data != nil {
		fields = append(fields, authcode.FieldConnectorData)
	}
	if m.expiry != nil {
		fields = append(fields, authcode.FieldExpiry)
	}
	if m.code_challenge != nil {
		fields = append(fields, authcode.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, authcode.FieldCodeChallengeMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authcode.FieldClientID:
		return m.ClientID()
	case authcode.FieldScopes:
		return m.Scopes()
	case authcode.FieldNonce:
		return m.Nonce()
	case authcode.FieldRedirectURI:
		return m.RedirectURI()
	case authcode.FieldClaimsUserID:
		return m.ClaimsUserID()
	case authcode.FieldClaimsUsername:
		return m.ClaimsUsername()
	case authcode.FieldClaimsEmail:
		return m.ClaimsEmail()
	case authcode.FieldClaimsEmailVerified:
		return m.ClaimsEmailVerified()
	case authcode.FieldClaimsGroups:
		return m.ClaimsGroups()
	case authcode.FieldClaimsPreferredUsername:
		return m.ClaimsPreferredUsername()
	case authcode.FieldConnectorID:
		return m.ConnectorID()
	case authcode.FieldConnectorData:
		return m.ConnectorData()
	case authcode.FieldExpiry:
		return m.Expiry()
	case authcode.FieldCodeChallenge:
		return m.CodeChallenge()
	case authcode.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authcode.FieldClientID:
		return m.OldClientID(ctx)
	case authcode.FieldScopes:
		return m.OldScopes(ctx)
	case authcode.FieldNonce:
		return m.OldNonce(ctx)
	case authcode.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case authcode.FieldClaimsUserID:
		return m.OldClaimsUserID(ctx)
	case authcode.FieldClaimsUsername:
		return m.OldClaimsUsername(ctx)
	case authcode.FieldClaimsEmail:
		return m.OldClaimsEmail(ctx)
	case authcode.FieldClaimsEmailVerified:
		return m.OldClaimsEmailVerified(ctx)
	case authcode.FieldClaimsGroups:
		return m.OldClaimsGroups(ctx)
	case authcode.FieldClaimsPreferredUsername:
		return m.OldClaimsPreferredUsername(ctx)
	case authcode.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case authcode.FieldConnectorData:
		return m.OldConnectorData(ctx)
	case authcode.FieldExpiry:
		return m.OldExpiry(ctx)
	case authcode.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case authcode.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	}
	return nil, fmt.Errorf("unknown AuthCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authcode.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case authcode.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case authcode.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case authcode.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case authcode.FieldClaimsUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUserID(v)
		return nil
	case authcode.FieldClaimsUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUsername(v)
		return nil
	case authcode.FieldClaimsEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmail(v)
		return nil
	case authcode.FieldClaimsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmailVerified(v)
		return nil
	case authcode.FieldClaimsGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsGroups(v)
		return nil
	case authcode.FieldClaimsPreferredUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsPreferredUsername(v)
		return nil
	case authcode.FieldConnectorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case authcode.FieldConnectorData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorData(v)
		return nil
	case authcode.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case authcode.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case authcode.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	}
	return fmt.Errorf("unknown AuthCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authcode.FieldScopes) {
		fields = append(fields, authcode.FieldScopes)
	}
	if m.FieldCleared(authcode.FieldClaimsGroups) {
		fields = append(fields, authcode.FieldClaimsGroups)
	}
	if m.FieldCleared(authcode.FieldConnectorData) {
		fields = append(fields, authcode.FieldConnectorData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthCodeMutation) ClearField(name string) error {
	switch name {
	case authcode.FieldScopes:
		m.ClearScopes()
		return nil
	case authcode.FieldClaimsGroups:
		m.ClearClaimsGroups()
		return nil
	case authcode.FieldConnectorData:
		m.ClearConnectorData()
		return nil
	}
	return fmt.Errorf("unknown AuthCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthCodeMutation) ResetField(name string) error {
	switch name {
	case authcode.FieldClientID:
		m.ResetClientID()
		return nil
	case authcode.FieldScopes:
		m.ResetScopes()
		return nil
	case authcode.FieldNonce:
		m.ResetNonce()
		return nil
	case authcode.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case authcode.FieldClaimsUserID:
		m.ResetClaimsUserID()
		return nil
	case authcode.FieldClaimsUsername:
		m.ResetClaimsUsername()
		return nil
	case authcode.FieldClaimsEmail:
		m.ResetClaimsEmail()
		return nil
	case authcode.FieldClaimsEmailVerified:
		m.ResetClaimsEmailVerified()
		return nil
	case authcode.FieldClaimsGroups:
		m.ResetClaimsGroups()
		return nil
	case authcode.FieldClaimsPreferredUsername:
		m.ResetClaimsPreferredUsername()
		return nil
	case authcode.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case authcode.FieldConnectorData:
		m.ResetConnectorData()
		return nil
	case authcode.FieldExpiry:
		m.ResetExpiry()
		return nil
	case authcode.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case authcode.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	}
	return fmt.Errorf("unknown AuthCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthCode edge %s", name)
}

// AuthRequestMutation represents an operation that mutates the AuthRequest nodes in the graph.
type AuthRequestMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	client_id                 *string
	scopes                    *[]string
	appendscopes              []string
	response_types            *[]string
	appendresponse_types      []string
	redirect_uri              *string
	nonce                     *string
	state                     *string
	force_approval_prompt     *bool
	logged_in                 *bool
	claims_user_id            *string
	claims_username           *string
	claims_email              *string
	claims_email_verified     *bool
	claims_groups             *[]string
	appendclaims_groups       []string
	claims_preferred_username *string
	connector_id              *string
	connector_data            *[]byte
	expiry                    *time.Time
	code_challenge            *string
	code_challenge_method     *string
	hmac_key                  *[]byte
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*AuthRequest, error)
	predicates                []predicate.AuthRequest
}

var _ ent.Mutation = (*AuthRequestMutation)(nil)

// authrequestOption allows management of the mutation configuration using functional options.
type authrequestOption func(*AuthRequestMutation)

// newAuthRequestMutation creates new mutation for the AuthRequest entity.
func newAuthRequestMutation(c config, op Op, opts ...authrequestOption) *AuthRequestMutation {
	m := &AuthRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRequestID sets the ID field of the mutation.
func withAuthRequestID(id string) authrequestOption {
	return func(m *AuthRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRequest
		)
		m.oldValue = func(ctx context.Context) (*AuthRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRequest sets the old AuthRequest of the mutation.
func withAuthRequest(node *AuthRequest) authrequestOption {
	return func(m *AuthRequestMutation) {
		m.oldValue = func(context.Context) (*AuthRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthRequest entities.
func (m *AuthRequestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRequestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthRequestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *AuthRequestMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthRequestMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthRequestMutation) ResetClientID() {
	m.client_id = nil
}

// SetScopes sets the "scopes" field.
func (m *AuthRequestMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *AuthRequestMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *AuthRequestMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *AuthRequestMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *AuthRequestMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[authrequest.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *AuthRequestMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[authrequest.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *AuthRequestMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, authrequest.FieldScopes)
}

// SetResponseTypes sets the "response_types" field.
func (m *AuthRequestMutation) SetResponseTypes(s []string) {
	m.response_types = &s
	m.appendresponse_types = nil
}

// ResponseTypes returns the value of the "response_types" field in the mutation.
func (m *AuthRequestMutation) ResponseTypes() (r []string, exists bool) {
	v := m.response_types
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTypes returns the old "response_types" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldResponseTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTypes: %w", err)
	}
	return oldValue.ResponseTypes, nil
}

// AppendResponseTypes adds s to the "response_types" field.
func (m *AuthRequestMutation) AppendResponseTypes(s []string) {
	m.appendresponse_types = append(m.appendresponse_types, s...)
}

// AppendedResponseTypes returns the list of values that were appended to the "response_types" field in this mutation.
func (m *AuthRequestMutation) AppendedResponseTypes() ([]string, bool) {
	if len(m.appendresponse_types) == 0 {
		return nil, false
	}
	return m.appendresponse_types, true
}

// ClearResponseTypes clears the value of the "response_types" field.
func (m *AuthRequestMutation) ClearResponseTypes() {
	m.response_types = nil
	m.appendresponse_types = nil
	m.clearedFields[authrequest.FieldResponseTypes] = struct{}{}
}

// ResponseTypesCleared returns if the "response_types" field was cleared in this mutation.
func (m *AuthRequestMutation) ResponseTypesCleared() bool {
	_, ok := m.clearedFields[authrequest.FieldResponseTypes]
	return ok
}

// ResetResponseTypes resets all changes to the "response_types" field.
func (m *AuthRequestMutation) ResetResponseTypes() {
	m.response_types = nil
	m.appendresponse_types = nil
	delete(m.clearedFields, authrequest.FieldResponseTypes)
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AuthRequestMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AuthRequestMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AuthRequestMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetNonce sets the "nonce" field.
func (m *AuthRequestMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *AuthRequestMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *AuthRequestMutation) ResetNonce() {
	m.nonce = nil
}

// SetState sets the "state" field.
func (m *AuthRequestMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AuthRequestMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AuthRequestMutation) ResetState() {
	m.state = nil
}

// SetForceApprovalPrompt sets the "force_approval_prompt" field.
func (m *AuthRequestMutation) SetForceApprovalPrompt(b bool) {
	m.force_approval_prompt = &b
}

// ForceApprovalPrompt returns the value of the "force_approval_prompt" field in the mutation.
func (m *AuthRequestMutation) ForceApprovalPrompt() (r bool, exists bool) {
	v := m.force_approval_prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldForceApprovalPrompt returns the old "force_approval_prompt" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldForceApprovalPrompt(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForceApprovalPrompt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForceApprovalPrompt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForceApprovalPrompt: %w", err)
	}
	return oldValue.ForceApprovalPrompt, nil
}

// ResetForceApprovalPrompt resets all changes to the "force_approval_prompt" field.
func (m *AuthRequestMutation) ResetForceApprovalPrompt() {
	m.force_approval_prompt = nil
}

// SetLoggedIn sets the "logged_in" field.
func (m *AuthRequestMutation) SetLoggedIn(b bool) {
	m.logged_in = &b
}

// LoggedIn returns the value of the "logged_in" field in the mutation.
func (m *AuthRequestMutation) LoggedIn() (r bool, exists bool) {
	v := m.logged_in
	if v == nil {
		return
	}
	return *v, true
}

// OldLoggedIn returns the old "logged_in" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldLoggedIn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoggedIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoggedIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoggedIn: %w", err)
	}
	return oldValue.LoggedIn, nil
}

// ResetLoggedIn resets all changes to the "logged_in" field.
func (m *AuthRequestMutation) ResetLoggedIn() {
	m.logged_in = nil
}

// SetClaimsUserID sets the "claims_user_id" field.
func (m *AuthRequestMutation) SetClaimsUserID(s string) {
	m.claims_user_id = &s
}

// ClaimsUserID returns the value of the "claims_user_id" field in the mutation.
func (m *AuthRequestMutation) ClaimsUserID() (r string, exists bool) {
	v := m.claims_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUserID returns the old "claims_user_id" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUserID: %w", err)
	}
	return oldValue.ClaimsUserID, nil
}

// ResetClaimsUserID resets all changes to the "claims_user_id" field.
func (m *AuthRequestMutation) ResetClaimsUserID() {
	m.claims_user_id = nil
}

// SetClaimsUsername sets the "claims_username" field.
func (m *AuthRequestMutation) SetClaimsUsername(s string) {
	m.claims_username = &s
}

// ClaimsUsername returns the value of the "claims_username" field in the mutation.
func (m *AuthRequestMutation) ClaimsUsername() (r string, exists bool) {
	v := m.claims_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUsername returns the old "claims_username" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUsername: %w", err)
	}
	return oldValue.ClaimsUsername, nil
}

// ResetClaimsUsername resets all changes to the "claims_username" field.
func (m *AuthRequestMutation) ResetClaimsUsername() {
	m.claims_username = nil
}

// SetClaimsEmail sets the "claims_email" field.
func (m *AuthRequestMutation) SetClaimsEmail(s string) {
	m.claims_email = &s
}

// ClaimsEmail returns the value of the "claims_email" field in the mutation.
func (m *AuthRequestMutation) ClaimsEmail() (r string, exists bool) {
	v := m.claims_email
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmail returns the old "claims_email" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmail: %w", err)
	}
	return oldValue.ClaimsEmail, nil
}

// ResetClaimsEmail resets all changes to the "claims_email" field.
func (m *AuthRequestMutation) ResetClaimsEmail() {
	m.claims_email = nil
}

// SetClaimsEmailVerified sets the "claims_email_verified" field.
func (m *AuthRequestMutation) SetClaimsEmailVerified(b bool) {
	m.claims_email_verified = &b
}

// ClaimsEmailVerified returns the value of the "claims_email_verified" field in the mutation.
func (m *AuthRequestMutation) ClaimsEmailVerified() (r bool, exists bool) {
	v := m.claims_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmailVerified returns the old "claims_email_verified" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmailVerified: %w", err)
	}
	return oldValue.ClaimsEmailVerified, nil
}

// ResetClaimsEmailVerified resets all changes to the "claims_email_verified" field.
func (m *AuthRequestMutation) ResetClaimsEmailVerified() {
	m.claims_email_verified = nil
}

// SetClaimsGroups sets the "claims_groups" field.
func (m *AuthRequestMutation) SetClaimsGroups(s []string) {
	m.claims_groups = &s
	m.appendclaims_groups = nil
}

// ClaimsGroups returns the value of the "claims_groups" field in the mutation.
func (m *AuthRequestMutation) ClaimsGroups() (r []string, exists bool) {
	v := m.claims_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsGroups returns the old "claims_groups" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsGroups: %w", err)
	}
	return oldValue.ClaimsGroups, nil
}

// AppendClaimsGroups adds s to the "claims_groups" field.
func (m *AuthRequestMutation) AppendClaimsGroups(s []string) {
	m.appendclaims_groups = append(m.appendclaims_groups, s...)
}

// AppendedClaimsGroups returns the list of values that were appended to the "claims_groups" field in this mutation.
func (m *AuthRequestMutation) AppendedClaimsGroups() ([]string, bool) {
	if len(m.appendclaims_groups) == 0 {
		return nil, false
	}
	return m.appendclaims_groups, true
}

// ClearClaimsGroups clears the value of the "claims_groups" field.
func (m *AuthRequestMutation) ClearClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	m.clearedFields[authrequest.FieldClaimsGroups] = struct{}{}
}

// ClaimsGroupsCleared returns if the "claims_groups" field was cleared in this mutation.
func (m *AuthRequestMutation) ClaimsGroupsCleared() bool {
	_, ok := m.clearedFields[authrequest.FieldClaimsGroups]
	return ok
}

// ResetClaimsGroups resets all changes to the "claims_groups" field.
func (m *AuthRequestMutation) ResetClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	delete(m.clearedFields, authrequest.FieldClaimsGroups)
}

// SetClaimsPreferredUsername sets the "claims_preferred_username" field.
func (m *AuthRequestMutation) SetClaimsPreferredUsername(s string) {
	m.claims_preferred_username = &s
}

// ClaimsPreferredUsername returns the value of the "claims_preferred_username" field in the mutation.
func (m *AuthRequestMutation) ClaimsPreferredUsername() (r string, exists bool) {
	v := m.claims_preferred_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsPreferredUsername returns the old "claims_preferred_username" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsPreferredUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsPreferredUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsPreferredUsername: %w", err)
	}
	return oldValue.ClaimsPreferredUsername, nil
}

// ResetClaimsPreferredUsername resets all changes to the "claims_preferred_username" field.
func (m *AuthRequestMutation) ResetClaimsPreferredUsername() {
	m.claims_preferred_username = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *AuthRequestMutation) SetConnectorID(s string) {
	m.connector_id = &s
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *AuthRequestMutation) ConnectorID() (r string, exists bool) {
	v := m.connector_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldConnectorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *AuthRequestMutation) ResetConnectorID() {
	m.connector_id = nil
}

// SetConnectorData sets the "connector_data" field.
func (m *AuthRequestMutation) SetConnectorData(b []byte) {
	m.connector_data = &b
}

// ConnectorData returns the value of the "connector_data" field in the mutation.
func (m *AuthRequestMutation) ConnectorData() (r []byte, exists bool) {
	v := m.connector_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorData returns the old "connector_data" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorData: %w", err)
	}
	return oldValue.ConnectorData, nil
}

// ClearConnectorData clears the value of the "connector_data" field.
func (m *AuthRequestMutation) ClearConnectorData() {
	m.connector_data = nil
	m.clearedFields[authrequest.FieldConnectorData] = struct{}{}
}

// ConnectorDataCleared returns if the "connector_data" field was cleared in this mutation.
func (m *AuthRequestMutation) ConnectorDataCleared() bool {
	_, ok := m.clearedFields[authrequest.FieldConnectorData]
	return ok
}

// ResetConnectorData resets all changes to the "connector_data" field.
func (m *AuthRequestMutation) ResetConnectorData() {
	m.connector_data = nil
	delete(m.clearedFields, authrequest.FieldConnectorData)
}

// SetExpiry sets the "expiry" field.
func (m *AuthRequestMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *AuthRequestMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *AuthRequestMutation) ResetExpiry() {
	m.expiry = nil
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *AuthRequestMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *AuthRequestMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *AuthRequestMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *AuthRequestMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *AuthRequestMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *AuthRequestMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// SetHmacKey sets the "hmac_key" field.
func (m *AuthRequestMutation) SetHmacKey(b []byte) {
	m.hmac_key = &b
}

// HmacKey returns the value of the "hmac_key" field in the mutation.
func (m *AuthRequestMutation) HmacKey() (r []byte, exists bool) {
	v := m.hmac_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHmacKey returns the old "hmac_key" field's value of the AuthRequest entity.
// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRequestMutation) OldHmacKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHmacKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHmacKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHmacKey: %w", err)
	}
	return oldValue.HmacKey, nil
}

// ResetHmacKey resets all changes to the "hmac_key" field.
func (m *AuthRequestMutation) ResetHmacKey() {
	m.hmac_key = nil
}

// Where appends a list predicates to the AuthRequestMutation builder.
func (m *AuthRequestMutation) Where(ps ...predicate.AuthRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthRequest).
func (m *AuthRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRequestMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.client_id != nil {
		fields = append(fields, authrequest.FieldClientID)
	}
	if m.scopes != nil {
		fields = append(fields, authrequest.FieldScopes)
	}
	if m.response_types != nil {
		fields = append(fields, authrequest.FieldResponseTypes)
	}
	if m.redirect_uri != nil {
		fields = append(fields, authrequest.FieldRedirectURI)
	}
	if m.nonce != nil {
		fields = append(fields, authrequest.FieldNonce)
	}
	if m.state != nil {
		fields = append(fields, authrequest.FieldState)
	}
	if m.force_approval_prompt != nil {
		fields = append(fields, authrequest.FieldForceApprovalPrompt)
	}
	if m.logged_in != nil {
		fields = append(fields, authrequest.FieldLoggedIn)
	}
	if m.claims_user_id != nil {
		fields = append(fields, authrequest.FieldClaimsUserID)
	}
	if m.claims_username != nil {
		fields = append(fields, authrequest.FieldClaimsUsername)
	}
	if m.claims_email != nil {
		fields = append(fields, authrequest.FieldClaimsEmail)
	}
	if m.claims_email_verified != nil {
		fields = append(fields, authrequest.FieldClaimsEmailVerified)
	}
	if m.claims_groups != nil {
		fields = append(fields, authrequest.FieldClaimsGroups)
	}
	if m.claims_preferred_username != nil {
		fields = append(fields, authrequest.FieldClaimsPreferredUsername)
	}
	if m.connector_id != nil {
		fields = append(fields, authrequest.FieldConnectorID)
	}
	if m.connector_data != nil {
		fields = append(fields, authrequest.FieldConnectorData)
	}
	if m.expiry != nil {
		fields = append(fields, authrequest.FieldExpiry)
	}
	if m.code_challenge != nil {
		fields = append(fields, authrequest.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, authrequest.FieldCodeChallengeMethod)
	}
	if m.hmac_key != nil {
		fields = append(fields, authrequest.FieldHmacKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authrequest.FieldClientID:
		return m.ClientID()
	case authrequest.FieldScopes:
		return m.Scopes()
	case authrequest.FieldResponseTypes:
		return m.ResponseTypes()
	case authrequest.FieldRedirectURI:
		return m.RedirectURI()
	case authrequest.FieldNonce:
		return m.Nonce()
	case authrequest.FieldState:
		return m.State()
	case authrequest.FieldForceApprovalPrompt:
		return m.ForceApprovalPrompt()
	case authrequest.FieldLoggedIn:
		return m.LoggedIn()
	case authrequest.FieldClaimsUserID:
		return m.ClaimsUserID()
	case authrequest.FieldClaimsUsername:
		return m.ClaimsUsername()
	case authrequest.FieldClaimsEmail:
		return m.ClaimsEmail()
	case authrequest.FieldClaimsEmailVerified:
		return m.ClaimsEmailVerified()
	case authrequest.FieldClaimsGroups:
		return m.ClaimsGroups()
	case authrequest.FieldClaimsPreferredUsername:
		return m.ClaimsPreferredUsername()
	case authrequest.FieldConnectorID:
		return m.ConnectorID()
	case authrequest.FieldConnectorData:
		return m.ConnectorData()
	case authrequest.FieldExpiry:
		return m.Expiry()
	case authrequest.FieldCodeChallenge:
		return m.CodeChallenge()
	case authrequest.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case authrequest.FieldHmacKey:
		return m.HmacKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authrequest.FieldClientID:
		return m.OldClientID(ctx)
	case authrequest.FieldScopes:
		return m.OldScopes(ctx)
	case authrequest.FieldResponseTypes:
		return m.OldResponseTypes(ctx)
	case authrequest.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case authrequest.FieldNonce:
		return m.OldNonce(ctx)
	case authrequest.FieldState:
		return m.OldState(ctx)
	case authrequest.FieldForceApprovalPrompt:
		return m.OldForceApprovalPrompt(ctx)
	case authrequest.FieldLoggedIn:
		return m.OldLoggedIn(ctx)
	case authrequest.FieldClaimsUserID:
		return m.OldClaimsUserID(ctx)
	case authrequest.FieldClaimsUsername:
		return m.OldClaimsUsername(ctx)
	case authrequest.FieldClaimsEmail:
		return m.OldClaimsEmail(ctx)
	case authrequest.FieldClaimsEmailVerified:
		return m.OldClaimsEmailVerified(ctx)
	case authrequest.FieldClaimsGroups:
		return m.OldClaimsGroups(ctx)
	case authrequest.FieldClaimsPreferredUsername:
		return m.OldClaimsPreferredUsername(ctx)
	case authrequest.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case authrequest.FieldConnectorData:
		return m.OldConnectorData(ctx)
	case authrequest.FieldExpiry:
		return m.OldExpiry(ctx)
	case authrequest.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case authrequest.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case authrequest.FieldHmacKey:
		return m.OldHmacKey(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authrequest.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case authrequest.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case authrequest.FieldResponseTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTypes(v)
		return nil
	case authrequest.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case authrequest.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case authrequest.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case authrequest.FieldForceApprovalPrompt:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForceApprovalPrompt(v)
		return nil
	case authrequest.FieldLoggedIn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoggedIn(v)
		return nil
	case authrequest.FieldClaimsUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUserID(v)
		return nil
	case authrequest.FieldClaimsUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUsername(v)
		return nil
	case authrequest.FieldClaimsEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmail(v)
		return nil
	case authrequest.FieldClaimsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmailVerified(v)
		return nil
	case authrequest.FieldClaimsGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsGroups(v)
		return nil
	case authrequest.FieldClaimsPreferredUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsPreferredUsername(v)
		return nil
	case authrequest.FieldConnectorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case authrequest.FieldConnectorData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorData(v)
		return nil
	case authrequest.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case authrequest.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case authrequest.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case authrequest.FieldHmacKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHmacKey(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authrequest.FieldScopes) {
		fields = append(fields, authrequest.FieldScopes)
	}
	if m.FieldCleared(authrequest.FieldResponseTypes) {
		fields = append(fields, authrequest.FieldResponseTypes)
	}
	if m.FieldCleared(authrequest.FieldClaimsGroups) {
		fields = append(fields, authrequest.FieldClaimsGroups)
	}
	if m.FieldCleared(authrequest.FieldConnectorData) {
		fields = append(fields, authrequest.FieldConnectorData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRequestMutation) ClearField(name string) error {
	switch name {
	case authrequest.FieldScopes:
		m.ClearScopes()
		return nil
	case authrequest.FieldResponseTypes:
		m.ClearResponseTypes()
		return nil
	case authrequest.FieldClaimsGroups:
		m.ClearClaimsGroups()
		return nil
	case authrequest.FieldConnectorData:
		m.ClearConnectorData()
		return nil
	}
	return fmt.Errorf("unknown AuthRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRequestMutation) ResetField(name string) error {
	switch name {
	case authrequest.FieldClientID:
		m.ResetClientID()
		return nil
	case authrequest.FieldScopes:
		m.ResetScopes()
		return nil
	case authrequest.FieldResponseTypes:
		m.ResetResponseTypes()
		return nil
	case authrequest.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case authrequest.FieldNonce:
		m.ResetNonce()
		return nil
	case authrequest.FieldState:
		m.ResetState()
		return nil
	case authrequest.FieldForceApprovalPrompt:
		m.ResetForceApprovalPrompt()
		return nil
	case authrequest.FieldLoggedIn:
		m.ResetLoggedIn()
		return nil
	case authrequest.FieldClaimsUserID:
		m.ResetClaimsUserID()
		return nil
	case authrequest.FieldClaimsUsername:
		m.ResetClaimsUsername()
		return nil
	case authrequest.FieldClaimsEmail:
		m.ResetClaimsEmail()
		return nil
	case authrequest.FieldClaimsEmailVerified:
		m.ResetClaimsEmailVerified()
		return nil
	case authrequest.FieldClaimsGroups:
		m.ResetClaimsGroups()
		return nil
	case authrequest.FieldClaimsPreferredUsername:
		m.ResetClaimsPreferredUsername()
		return nil
	case authrequest.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case authrequest.FieldConnectorData:
		m.ResetConnectorData()
		return nil
	case authrequest.FieldExpiry:
		m.ResetExpiry()
		return nil
	case authrequest.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case authrequest.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case authrequest.FieldHmacKey:
		m.ResetHmacKey()
		return nil
	}
	return fmt.Errorf("unknown AuthRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthRequest edge %s", name)
}

// ConnectorMutation represents an operation that mutates the Connector nodes in the graph.
type ConnectorMutation struct {
	config
	op               Op
	typ              string
	id               *string
	_type            *string
	name             *string
	resource_version *string
	_config          *[]byte
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Connector, error)
	predicates       []predicate.Connector
}

var _ ent.Mutation = (*ConnectorMutation)(nil)

// connectorOption allows management of the mutation configuration using functional options.
type connectorOption func(*ConnectorMutation)

// newConnectorMutation creates new mutation for the Connector entity.
func newConnectorMutation(c config, op Op, opts ...connectorOption) *ConnectorMutation {
	m := &ConnectorMutation{
		config:        c,
		op:            op,
		typ:           TypeConnector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectorID sets the ID field of the mutation.
func withConnectorID(id string) connectorOption {
	return func(m *ConnectorMutation) {
		var (
			err   error
			once  sync.Once
			value *Connector
		)
		m.oldValue = func(ctx context.Context) (*Connector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnector sets the old Connector of the mutation.
func withConnector(node *Connector) connectorOption {
	return func(m *ConnectorMutation) {
		m.oldValue = func(context.Context) (*Connector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connector entities.
func (m *ConnectorMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectorMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectorMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ConnectorMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConnectorMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ConnectorMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ConnectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectorMutation) ResetName() {
	m.name = nil
}

// SetResourceVersion sets the "resource_version" field.
func (m *ConnectorMutation) SetResourceVersion(s string) {
	m.resource_version = &s
}

// ResourceVersion returns the value of the "resource_version" field in the mutation.
func (m *ConnectorMutation) ResourceVersion() (r string, exists bool) {
	v := m.resource_version
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceVersion returns the old "resource_version" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldResourceVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceVersion: %w", err)
	}
	return oldValue.ResourceVersion, nil
}

// ResetResourceVersion resets all changes to the "resource_version" field.
func (m *ConnectorMutation) ResetResourceVersion() {
	m.resource_version = nil
}

// SetConfig sets the "config" field.
func (m *ConnectorMutation) SetConfig(b []byte) {
	m._config = &b
}

// Config returns the value of the "config" field in the mutation.
func (m *ConnectorMutation) Config() (r []byte, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldConfig(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *ConnectorMutation) ResetConfig() {
	m._config = nil
}

// Where appends a list predicates to the ConnectorMutation builder.
func (m *ConnectorMutation) Where(ps ...predicate.Connector) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Connector, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Connector).
func (m *ConnectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, connector.FieldType)
	}
	if m.name != nil {
		fields = append(fields, connector.FieldName)
	}
	if m.resource_version != nil {
		fields = append(fields, connector.FieldResourceVersion)
	}
	if m._config != nil {
		fields = append(fields, connector.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connector.FieldType:
		return m.GetType()
	case connector.FieldName:
		return m.Name()
	case connector.FieldResourceVersion:
		return m.ResourceVersion()
	case connector.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connector.FieldType:
		return m.OldType(ctx)
	case connector.FieldName:
		return m.OldName(ctx)
	case connector.FieldResourceVersion:
		return m.OldResourceVersion(ctx)
	case connector.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Connector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connector.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case connector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case connector.FieldResourceVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceVersion(v)
		return nil
	case connector.FieldConfig:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Connector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectorMutation) ResetField(name string) error {
	switch name {
	case connector.FieldType:
		m.ResetType()
		return nil
	case connector.FieldName:
		m.ResetName()
		return nil
	case connector.FieldResourceVersion:
		m.ResetResourceVersion()
		return nil
	case connector.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Connector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Connector edge %s", name)
}

// DeviceRequestMutation represents an operation that mutates the DeviceRequest nodes in the graph.
type DeviceRequestMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_code     *string
	device_code   *string
	client_id     *string
	client_secret *string
	scopes        *[]string
	appendscopes  []string
	expiry        *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DeviceRequest, error)
	predicates    []predicate.DeviceRequest
}

var _ ent.Mutation = (*DeviceRequestMutation)(nil)

// devicerequestOption allows management of the mutation configuration using functional options.
type devicerequestOption func(*DeviceRequestMutation)

// newDeviceRequestMutation creates new mutation for the DeviceRequest entity.
func newDeviceRequestMutation(c config, op Op, opts ...devicerequestOption) *DeviceRequestMutation {
	m := &DeviceRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceRequestID sets the ID field of the mutation.
func withDeviceRequestID(id int) devicerequestOption {
	return func(m *DeviceRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceRequest
		)
		m.oldValue = func(ctx context.Context) (*DeviceRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceRequest sets the old DeviceRequest of the mutation.
func withDeviceRequest(node *DeviceRequest) devicerequestOption {
	return func(m *DeviceRequestMutation) {
		m.oldValue = func(context.Context) (*DeviceRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserCode sets the "user_code" field.
func (m *DeviceRequestMutation) SetUserCode(s string) {
	m.user_code = &s
}

// UserCode returns the value of the "user_code" field in the mutation.
func (m *DeviceRequestMutation) UserCode() (r string, exists bool) {
	v := m.user_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCode returns the old "user_code" field's value of the DeviceRequest entity.
// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRequestMutation) OldUserCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCode: %w", err)
	}
	return oldValue.UserCode, nil
}

// ResetUserCode resets all changes to the "user_code" field.
func (m *DeviceRequestMutation) ResetUserCode() {
	m.user_code = nil
}

// SetDeviceCode sets the "device_code" field.
func (m *DeviceRequestMutation) SetDeviceCode(s string) {
	m.device_code = &s
}

// DeviceCode returns the value of the "device_code" field in the mutation.
func (m *DeviceRequestMutation) DeviceCode() (r string, exists bool) {
	v := m.device_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceCode returns the old "device_code" field's value of the DeviceRequest entity.
// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRequestMutation) OldDeviceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceCode: %w", err)
	}
	return oldValue.DeviceCode, nil
}

// ResetDeviceCode resets all changes to the "device_code" field.
func (m *DeviceRequestMutation) ResetDeviceCode() {
	m.device_code = nil
}

// SetClientID sets the "client_id" field.
func (m *DeviceRequestMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *DeviceRequestMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the DeviceRequest entity.
// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRequestMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *DeviceRequestMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *DeviceRequestMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *DeviceRequestMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the DeviceRequest entity.
// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRequestMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *DeviceRequestMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetScopes sets the "scopes" field.
func (m *DeviceRequestMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *DeviceRequestMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the DeviceRequest entity.
// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRequestMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *DeviceRequestMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *DeviceRequestMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *DeviceRequestMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[devicerequest.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *DeviceRequestMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[devicerequest.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *DeviceRequestMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, devicerequest.FieldScopes)
}

// SetExpiry sets the "expiry" field.
func (m *DeviceRequestMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *DeviceRequestMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the DeviceRequest entity.
// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRequestMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *DeviceRequestMutation) ResetExpiry() {
	m.expiry = nil
}

// Where appends a list predicates to the DeviceRequestMutation builder.
func (m *DeviceRequestMutation) Where(ps ...predicate.DeviceRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceRequest).
func (m *DeviceRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceRequestMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_code != nil {
		fields = append(fields, devicerequest.FieldUserCode)
	}
	if m.device_code != nil {
		fields = append(fields, devicerequest.FieldDeviceCode)
	}
	if m.client_id != nil {
		fields = append(fields, devicerequest.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, devicerequest.FieldClientSecret)
	}
	if m.scopes != nil {
		fields = append(fields, devicerequest.FieldScopes)
	}
	if m.expiry != nil {
		fields = append(fields, devicerequest.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicerequest.FieldUserCode:
		return m.UserCode()
	case devicerequest.FieldDeviceCode:
		return m.DeviceCode()
	case devicerequest.FieldClientID:
		return m.ClientID()
	case devicerequest.FieldClientSecret:
		return m.ClientSecret()
	case devicerequest.FieldScopes:
		return m.Scopes()
	case devicerequest.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicerequest.FieldUserCode:
		return m.OldUserCode(ctx)
	case devicerequest.FieldDeviceCode:
		return m.OldDeviceCode(ctx)
	case devicerequest.FieldClientID:
		return m.OldClientID(ctx)
	case devicerequest.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case devicerequest.FieldScopes:
		return m.OldScopes(ctx)
	case devicerequest.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicerequest.FieldUserCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCode(v)
		return nil
	case devicerequest.FieldDeviceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceCode(v)
		return nil
	case devicerequest.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case devicerequest.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case devicerequest.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case devicerequest.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicerequest.FieldScopes) {
		fields = append(fields, devicerequest.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceRequestMutation) ClearField(name string) error {
	switch name {
	case devicerequest.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown DeviceRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceRequestMutation) ResetField(name string) error {
	switch name {
	case devicerequest.FieldUserCode:
		m.ResetUserCode()
		return nil
	case devicerequest.FieldDeviceCode:
		m.ResetDeviceCode()
		return nil
	case devicerequest.FieldClientID:
		m.ResetClientID()
		return nil
	case devicerequest.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case devicerequest.FieldScopes:
		m.ResetScopes()
		return nil
	case devicerequest.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown DeviceRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceRequest edge %s", name)
}

// DeviceTokenMutation represents an operation that mutates the DeviceToken nodes in the graph.
type DeviceTokenMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	device_code           *string
	status                *string
	token                 *[]byte
	expiry                *time.Time
	last_request          *time.Time
	poll_interval         *int
	addpoll_interval      *int
	code_challenge        *string
	code_challenge_method *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*DeviceToken, error)
	predicates            []predicate.DeviceToken
}

var _ ent.Mutation = (*DeviceTokenMutation)(nil)

// devicetokenOption allows management of the mutation configuration using functional options.
type devicetokenOption func(*DeviceTokenMutation)

// newDeviceTokenMutation creates new mutation for the DeviceToken entity.
func newDeviceTokenMutation(c config, op Op, opts ...devicetokenOption) *DeviceTokenMutation {
	m := &DeviceTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceTokenID sets the ID field of the mutation.
func withDeviceTokenID(id int) devicetokenOption {
	return func(m *DeviceTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceToken
		)
		m.oldValue = func(ctx context.Context) (*DeviceToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceToken sets the old DeviceToken of the mutation.
func withDeviceToken(node *DeviceToken) devicetokenOption {
	return func(m *DeviceTokenMutation) {
		m.oldValue = func(context.Context) (*DeviceToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceCode sets the "device_code" field.
func (m *DeviceTokenMutation) SetDeviceCode(s string) {
	m.device_code = &s
}

// DeviceCode returns the value of the "device_code" field in the mutation.
func (m *DeviceTokenMutation) DeviceCode() (r string, exists bool) {
	v := m.device_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceCode returns the old "device_code" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldDeviceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceCode: %w", err)
	}
	return oldValue.DeviceCode, nil
}

// ResetDeviceCode resets all changes to the "device_code" field.
func (m *DeviceTokenMutation) ResetDeviceCode() {
	m.device_code = nil
}

// SetStatus sets the "status" field.
func (m *DeviceTokenMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DeviceTokenMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DeviceTokenMutation) ResetStatus() {
	m.status = nil
}

// SetToken sets the "token" field.
func (m *DeviceTokenMutation) SetToken(b []byte) {
	m.token = &b
}

// Token returns the value of the "token" field in the mutation.
func (m *DeviceTokenMutation) Token() (r []byte, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldToken(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *DeviceTokenMutation) ClearToken() {
	m.token = nil
	m.clearedFields[devicetoken.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *DeviceTokenMutation) TokenCleared() bool {
	_, ok := m.clearedFields[devicetoken.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *DeviceTokenMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, devicetoken.FieldToken)
}

// SetExpiry sets the "expiry" field.
func (m *DeviceTokenMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *DeviceTokenMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *DeviceTokenMutation) ResetExpiry() {
	m.expiry = nil
}

// SetLastRequest sets the "last_request" field.
func (m *DeviceTokenMutation) SetLastRequest(t time.Time) {
	m.last_request = &t
}

// LastRequest returns the value of the "last_request" field in the mutation.
func (m *DeviceTokenMutation) LastRequest() (r time.Time, exists bool) {
	v := m.last_request
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRequest returns the old "last_request" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldLastRequest(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRequest: %w", err)
	}
	return oldValue.LastRequest, nil
}

// ResetLastRequest resets all changes to the "last_request" field.
func (m *DeviceTokenMutation) ResetLastRequest() {
	m.last_request = nil
}

// SetPollInterval sets the "poll_interval" field.
func (m *DeviceTokenMutation) SetPollInterval(i int) {
	m.poll_interval = &i
	m.addpoll_interval = nil
}

// PollInterval returns the value of the "poll_interval" field in the mutation.
func (m *DeviceTokenMutation) PollInterval() (r int, exists bool) {
	v := m.poll_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldPollInterval returns the old "poll_interval" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldPollInterval(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPollInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPollInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPollInterval: %w", err)
	}
	return oldValue.PollInterval, nil
}

// AddPollInterval adds i to the "poll_interval" field.
func (m *DeviceTokenMutation) AddPollInterval(i int) {
	if m.addpoll_interval != nil {
		*m.addpoll_interval += i
	} else {
		m.addpoll_interval = &i
	}
}

// AddedPollInterval returns the value that was added to the "poll_interval" field in this mutation.
func (m *DeviceTokenMutation) AddedPollInterval() (r int, exists bool) {
	v := m.addpoll_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetPollInterval resets all changes to the "poll_interval" field.
func (m *DeviceTokenMutation) ResetPollInterval() {
	m.poll_interval = nil
	m.addpoll_interval = nil
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *DeviceTokenMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *DeviceTokenMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *DeviceTokenMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *DeviceTokenMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *DeviceTokenMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *DeviceTokenMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// Where appends a list predicates to the DeviceTokenMutation builder.
func (m *DeviceTokenMutation) Where(ps ...predicate.DeviceToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceToken).
func (m *DeviceTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceTokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.device_code != nil {
		fields = append(fields, devicetoken.FieldDeviceCode)
	}
	if m.status != nil {
		fields = append(fields, devicetoken.FieldStatus)
	}
	if m.token != nil {
		fields = append(fields, devicetoken.FieldToken)
	}
	if m.expiry != nil {
		fields = append(fields, devicetoken.FieldExpiry)
	}
	if m.last_request != nil {
		fields = append(fields, devicetoken.FieldLastRequest)
	}
	if m.poll_interval != nil {
		fields = append(fields, devicetoken.FieldPollInterval)
	}
	if m.code_challenge != nil {
		fields = append(fields, devicetoken.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, devicetoken.FieldCodeChallengeMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicetoken.FieldDeviceCode:
		return m.DeviceCode()
	case devicetoken.FieldStatus:
		return m.Status()
	case devicetoken.FieldToken:
		return m.Token()
	case devicetoken.FieldExpiry:
		return m.Expiry()
	case devicetoken.FieldLastRequest:
		return m.LastRequest()
	case devicetoken.FieldPollInterval:
		return m.PollInterval()
	case devicetoken.FieldCodeChallenge:
		return m.CodeChallenge()
	case devicetoken.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicetoken.FieldDeviceCode:
		return m.OldDeviceCode(ctx)
	case devicetoken.FieldStatus:
		return m.OldStatus(ctx)
	case devicetoken.FieldToken:
		return m.OldToken(ctx)
	case devicetoken.FieldExpiry:
		return m.OldExpiry(ctx)
	case devicetoken.FieldLastRequest:
		return m.OldLastRequest(ctx)
	case devicetoken.FieldPollInterval:
		return m.OldPollInterval(ctx)
	case devicetoken.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case devicetoken.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicetoken.FieldDeviceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceCode(v)
		return nil
	case devicetoken.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case devicetoken.FieldToken:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case devicetoken.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case devicetoken.FieldLastRequest:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRequest(v)
		return nil
	case devicetoken.FieldPollInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPollInterval(v)
		return nil
	case devicetoken.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case devicetoken.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceTokenMutation) AddedFields() []string {
	var fields []string
	if m.addpoll_interval != nil {
		fields = append(fields, devicetoken.FieldPollInterval)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicetoken.FieldPollInterval:
		return m.AddedPollInterval()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicetoken.FieldPollInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPollInterval(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicetoken.FieldToken) {
		fields = append(fields, devicetoken.FieldToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceTokenMutation) ClearField(name string) error {
	switch name {
	case devicetoken.FieldToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown DeviceToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceTokenMutation) ResetField(name string) error {
	switch name {
	case devicetoken.FieldDeviceCode:
		m.ResetDeviceCode()
		return nil
	case devicetoken.FieldStatus:
		m.ResetStatus()
		return nil
	case devicetoken.FieldToken:
		m.ResetToken()
		return nil
	case devicetoken.FieldExpiry:
		m.ResetExpiry()
		return nil
	case devicetoken.FieldLastRequest:
		m.ResetLastRequest()
		return nil
	case devicetoken.FieldPollInterval:
		m.ResetPollInterval()
		return nil
	case devicetoken.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case devicetoken.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	}
	return fmt.Errorf("unknown DeviceToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceToken edge %s", name)
}

// KeysMutation represents an operation that mutates the Keys nodes in the graph.
type KeysMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	verification_keys       *[]storage.VerificationKey
	appendverification_keys []storage.VerificationKey
	signing_key             *jose.JSONWebKey
	signing_key_pub         *jose.JSONWebKey
	next_rotation           *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*Keys, error)
	predicates              []predicate.Keys
}

var _ ent.Mutation = (*KeysMutation)(nil)

// keysOption allows management of the mutation configuration using functional options.
type keysOption func(*KeysMutation)

// newKeysMutation creates new mutation for the Keys entity.
func newKeysMutation(c config, op Op, opts ...keysOption) *KeysMutation {
	m := &KeysMutation{
		config:        c,
		op:            op,
		typ:           TypeKeys,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeysID sets the ID field of the mutation.
func withKeysID(id string) keysOption {
	return func(m *KeysMutation) {
		var (
			err   error
			once  sync.Once
			value *Keys
		)
		m.oldValue = func(ctx context.Context) (*Keys, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Keys.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeys sets the old Keys of the mutation.
func withKeys(node *Keys) keysOption {
	return func(m *KeysMutation) {
		m.oldValue = func(context.Context) (*Keys, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeysMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeysMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Keys entities.
func (m *KeysMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeysMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeysMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Keys.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVerificationKeys sets the "verification_keys" field.
func (m *KeysMutation) SetVerificationKeys(sk []storage.VerificationKey) {
	m.verification_keys = &sk
	m.appendverification_keys = nil
}

// VerificationKeys returns the value of the "verification_keys" field in the mutation.
func (m *KeysMutation) VerificationKeys() (r []storage.VerificationKey, exists bool) {
	v := m.verification_keys
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationKeys returns the old "verification_keys" field's value of the Keys entity.
// If the Keys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeysMutation) OldVerificationKeys(ctx context.Context) (v []storage.VerificationKey, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationKeys is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationKeys requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationKeys: %w", err)
	}
	return oldValue.VerificationKeys, nil
}

// AppendVerificationKeys adds sk to the "verification_keys" field.
func (m *KeysMutation) AppendVerificationKeys(sk []storage.VerificationKey) {
	m.appendverification_keys = append(m.appendverification_keys, sk...)
}

// AppendedVerificationKeys returns the list of values that were appended to the "verification_keys" field in this mutation.
func (m *KeysMutation) AppendedVerificationKeys() ([]storage.VerificationKey, bool) {
	if len(m.appendverification_keys) == 0 {
		return nil, false
	}
	return m.appendverification_keys, true
}

// ResetVerificationKeys resets all changes to the "verification_keys" field.
func (m *KeysMutation) ResetVerificationKeys() {
	m.verification_keys = nil
	m.appendverification_keys = nil
}

// SetSigningKey sets the "signing_key" field.
func (m *KeysMutation) SetSigningKey(jwk jose.JSONWebKey) {
	m.signing_key = &jwk
}

// SigningKey returns the value of the "signing_key" field in the mutation.
func (m *KeysMutation) SigningKey() (r jose.JSONWebKey, exists bool) {
	v := m.signing_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningKey returns the old "signing_key" field's value of the Keys entity.
// If the Keys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeysMutation) OldSigningKey(ctx context.Context) (v jose.JSONWebKey, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningKey: %w", err)
	}
	return oldValue.SigningKey, nil
}

// ResetSigningKey resets all changes to the "signing_key" field.
func (m *KeysMutation) ResetSigningKey() {
	m.signing_key = nil
}

// SetSigningKeyPub sets the "signing_key_pub" field.
func (m *KeysMutation) SetSigningKeyPub(jwk jose.JSONWebKey) {
	m.signing_key_pub = &jwk
}

// SigningKeyPub returns the value of the "signing_key_pub" field in the mutation.
func (m *KeysMutation) SigningKeyPub() (r jose.JSONWebKey, exists bool) {
	v := m.signing_key_pub
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningKeyPub returns the old "signing_key_pub" field's value of the Keys entity.
// If the Keys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeysMutation) OldSigningKeyPub(ctx context.Context) (v jose.JSONWebKey, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningKeyPub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningKeyPub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningKeyPub: %w", err)
	}
	return oldValue.SigningKeyPub, nil
}

// ResetSigningKeyPub resets all changes to the "signing_key_pub" field.
func (m *KeysMutation) ResetSigningKeyPub() {
	m.signing_key_pub = nil
}

// SetNextRotation sets the "next_rotation" field.
func (m *KeysMutation) SetNextRotation(t time.Time) {
	m.next_rotation = &t
}

// NextRotation returns the value of the "next_rotation" field in the mutation.
func (m *KeysMutation) NextRotation() (r time.Time, exists bool) {
	v := m.next_rotation
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRotation returns the old "next_rotation" field's value of the Keys entity.
// If the Keys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeysMutation) OldNextRotation(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRotation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRotation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRotation: %w", err)
	}
	return oldValue.NextRotation, nil
}

// ResetNextRotation resets all changes to the "next_rotation" field.
func (m *KeysMutation) ResetNextRotation() {
	m.next_rotation = nil
}

// Where appends a list predicates to the KeysMutation builder.
func (m *KeysMutation) Where(ps ...predicate.Keys) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeysMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeysMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Keys, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeysMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeysMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Keys).
func (m *KeysMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeysMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.verification_keys != nil {
		fields = append(fields, keys.FieldVerificationKeys)
	}
	if m.signing_key != nil {
		fields = append(fields, keys.FieldSigningKey)
	}
	if m.signing_key_pub != nil {
		fields = append(fields, keys.FieldSigningKeyPub)
	}
	if m.next_rotation != nil {
		fields = append(fields, keys.FieldNextRotation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeysMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case keys.FieldVerificationKeys:
		return m.VerificationKeys()
	case keys.FieldSigningKey:
		return m.SigningKey()
	case keys.FieldSigningKeyPub:
		return m.SigningKeyPub()
	case keys.FieldNextRotation:
		return m.NextRotation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeysMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case keys.FieldVerificationKeys:
		return m.OldVerificationKeys(ctx)
	case keys.FieldSigningKey:
		return m.OldSigningKey(ctx)
	case keys.FieldSigningKeyPub:
		return m.OldSigningKeyPub(ctx)
	case keys.FieldNextRotation:
		return m.OldNextRotation(ctx)
	}
	return nil, fmt.Errorf("unknown Keys field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeysMutation) SetField(name string, value ent.Value) error {
	switch name {
	case keys.FieldVerificationKeys:
		v, ok := value.([]storage.VerificationKey)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationKeys(v)
		return nil
	case keys.FieldSigningKey:
		v, ok := value.(jose.JSONWebKey)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningKey(v)
		return nil
	case keys.FieldSigningKeyPub:
		v, ok := value.(jose.JSONWebKey)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningKeyPub(v)
		return nil
	case keys.FieldNextRotation:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRotation(v)
		return nil
	}
	return fmt.Errorf("unknown Keys field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeysMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeysMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeysMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Keys numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeysMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeysMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeysMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Keys nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeysMutation) ResetField(name string) error {
	switch name {
	case keys.FieldVerificationKeys:
		m.ResetVerificationKeys()
		return nil
	case keys.FieldSigningKey:
		m.ResetSigningKey()
		return nil
	case keys.FieldSigningKeyPub:
		m.ResetSigningKeyPub()
		return nil
	case keys.FieldNextRotation:
		m.ResetNextRotation()
		return nil
	}
	return fmt.Errorf("unknown Keys field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeysMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeysMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeysMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeysMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeysMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeysMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeysMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Keys unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeysMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Keys edge %s", name)
}

// OAuth2ClientMutation represents an operation that mutates the OAuth2Client nodes in the graph.
type OAuth2ClientMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	secret              *string
	redirect_uris       *[]string
	appendredirect_uris []string
	trusted_peers       *[]string
	appendtrusted_peers []string
	public              *bool
	name                *string
	logo_url            *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*OAuth2Client, error)
	predicates          []predicate.OAuth2Client
}

var _ ent.Mutation = (*OAuth2ClientMutation)(nil)

// oauth2clientOption allows management of the mutation configuration using functional options.
type oauth2clientOption func(*OAuth2ClientMutation)

// newOAuth2ClientMutation creates new mutation for the OAuth2Client entity.
func newOAuth2ClientMutation(c config, op Op, opts ...oauth2clientOption) *OAuth2ClientMutation {
	m := &OAuth2ClientMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuth2Client,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuth2ClientID sets the ID field of the mutation.
func withOAuth2ClientID(id string) oauth2clientOption {
	return func(m *OAuth2ClientMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuth2Client
		)
		m.oldValue = func(ctx context.Context) (*OAuth2Client, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuth2Client.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuth2Client sets the old OAuth2Client of the mutation.
func withOAuth2Client(node *OAuth2Client) oauth2clientOption {
	return func(m *OAuth2ClientMutation) {
		m.oldValue = func(context.Context) (*OAuth2Client, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuth2ClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuth2ClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuth2Client entities.
func (m *OAuth2ClientMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuth2ClientMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuth2ClientMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuth2Client.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSecret sets the "secret" field.
func (m *OAuth2ClientMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *OAuth2ClientMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the OAuth2Client entity.
// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuth2ClientMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *OAuth2ClientMutation) ResetSecret() {
	m.secret = nil
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *OAuth2ClientMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *OAuth2ClientMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the OAuth2Client entity.
// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuth2ClientMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *OAuth2ClientMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *OAuth2ClientMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ClearRedirectUris clears the value of the "redirect_uris" field.
func (m *OAuth2ClientMutation) ClearRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
	m.clearedFields[oauth2client.FieldRedirectUris] = struct{}{}
}

// RedirectUrisCleared returns if the "redirect_uris" field was cleared in this mutation.
func (m *OAuth2ClientMutation) RedirectUrisCleared() bool {
	_, ok := m.clearedFields[oauth2client.FieldRedirectUris]
	return ok
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *OAuth2ClientMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
	delete(m.clearedFields, oauth2client.FieldRedirectUris)
}

// SetTrustedPeers sets the "trusted_peers" field.
func (m *OAuth2ClientMutation) SetTrustedPeers(s []string) {
	m.trusted_peers = &s
	m.appendtrusted_peers = nil
}

// TrustedPeers returns the value of the "trusted_peers" field in the mutation.
func (m *OAuth2ClientMutation) TrustedPeers() (r []string, exists bool) {
	v := m.trusted_peers
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustedPeers returns the old "trusted_peers" field's value of the OAuth2Client entity.
// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuth2ClientMutation) OldTrustedPeers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustedPeers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustedPeers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustedPeers: %w", err)
	}
	return oldValue.TrustedPeers, nil
}

// AppendTrustedPeers adds s to the "trusted_peers" field.
func (m *OAuth2ClientMutation) AppendTrustedPeers(s []string) {
	m.appendtrusted_peers = append(m.appendtrusted_peers, s...)
}

// AppendedTrustedPeers returns the list of values that were appended to the "trusted_peers" field in this mutation.
func (m *OAuth2ClientMutation) AppendedTrustedPeers() ([]string, bool) {
	if len(m.appendtrusted_peers) == 0 {
		return nil, false
	}
	return m.appendtrusted_peers, true
}

// ClearTrustedPeers clears the value of the "trusted_peers" field.
func (m *OAuth2ClientMutation) ClearTrustedPeers() {
	m.trusted_peers = nil
	m.appendtrusted_peers = nil
	m.clearedFields[oauth2client.FieldTrustedPeers] = struct{}{}
}

// TrustedPeersCleared returns if the "trusted_peers" field was cleared in this mutation.
func (m *OAuth2ClientMutation) TrustedPeersCleared() bool {
	_, ok := m.clearedFields[oauth2client.FieldTrustedPeers]
	return ok
}

// ResetTrustedPeers resets all changes to the "trusted_peers" field.
func (m *OAuth2ClientMutation) ResetTrustedPeers() {
	m.trusted_peers = nil
	m.appendtrusted_peers = nil
	delete(m.clearedFields, oauth2client.FieldTrustedPeers)
}

// SetPublic sets the "public" field.
func (m *OAuth2ClientMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *OAuth2ClientMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the OAuth2Client entity.
// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuth2ClientMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *OAuth2ClientMutation) ResetPublic() {
	m.public = nil
}

// SetName sets the "name" field.
func (m *OAuth2ClientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OAuth2ClientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OAuth2Client entity.
// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuth2ClientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OAuth2ClientMutation) ResetName() {
	m.name = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *OAuth2ClientMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OAuth2ClientMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the OAuth2Client entity.
// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuth2ClientMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OAuth2ClientMutation) ResetLogoURL() {
	m.logo_url = nil
}

// Where appends a list predicates to the OAuth2ClientMutation builder.
func (m *OAuth2ClientMutation) Where(ps ...predicate.OAuth2Client) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuth2ClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuth2ClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuth2Client, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuth2ClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuth2ClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuth2Client).
func (m *OAuth2ClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuth2ClientMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.secret != nil {
		fields = append(fields, oauth2client.FieldSecret)
	}
	if m.redirect_uris != nil {
		fields = append(fields, oauth2client.FieldRedirectUris)
	}
	if m.trusted_peers != nil {
		fields = append(fields, oauth2client.FieldTrustedPeers)
	}
	if m.public != nil {
		fields = append(fields, oauth2client.FieldPublic)
	}
	if m.name != nil {
		fields = append(fields, oauth2client.FieldName)
	}
	if m.logo_url != nil {
		fields = append(fields, oauth2client.FieldLogoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuth2ClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2client.FieldSecret:
		return m.Secret()
	case oauth2client.FieldRedirectUris:
		return m.RedirectUris()
	case oauth2client.FieldTrustedPeers:
		return m.TrustedPeers()
	case oauth2client.FieldPublic:
		return m.Public()
	case oauth2client.FieldName:
		return m.Name()
	case oauth2client.FieldLogoURL:
		return m.LogoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuth2ClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2client.FieldSecret:
		return m.OldSecret(ctx)
	case oauth2client.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case oauth2client.FieldTrustedPeers:
		return m.OldTrustedPeers(ctx)
	case oauth2client.FieldPublic:
		return m.OldPublic(ctx)
	case oauth2client.FieldName:
		return m.OldName(ctx)
	case oauth2client.FieldLogoURL:
		return m.OldLogoURL(ctx)
	}
	return nil, fmt.Errorf("unknown OAuth2Client field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuth2ClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2client.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case oauth2client.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case oauth2client.FieldTrustedPeers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustedPeers(v)
		return nil
	case oauth2client.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case oauth2client.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauth2client.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	}
	return fmt.Errorf("unknown OAuth2Client field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuth2ClientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuth2ClientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuth2ClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuth2Client numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuth2ClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauth2client.FieldRedirectUris) {
		fields = append(fields, oauth2client.FieldRedirectUris)
	}
	if m.FieldCleared(oauth2client.FieldTrustedPeers) {
		fields = append(fields, oauth2client.FieldTrustedPeers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuth2ClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuth2ClientMutation) ClearField(name string) error {
	switch name {
	case oauth2client.FieldRedirectUris:
		m.ClearRedirectUris()
		return nil
	case oauth2client.FieldTrustedPeers:
		m.ClearTrustedPeers()
		return nil
	}
	return fmt.Errorf("unknown OAuth2Client nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuth2ClientMutation) ResetField(name string) error {
	switch name {
	case oauth2client.FieldSecret:
		m.ResetSecret()
		return nil
	case oauth2client.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case oauth2client.FieldTrustedPeers:
		m.ResetTrustedPeers()
		return nil
	case oauth2client.FieldPublic:
		m.ResetPublic()
		return nil
	case oauth2client.FieldName:
		m.ResetName()
		return nil
	case oauth2client.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	}
	return fmt.Errorf("unknown OAuth2Client field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuth2ClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuth2ClientMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuth2ClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuth2ClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuth2ClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuth2ClientMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuth2ClientMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OAuth2Client unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuth2ClientMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OAuth2Client edge %s", name)
}

// OfflineSessionMutation represents an operation that mutates the OfflineSession nodes in the graph.
type OfflineSessionMutation struct {
	config
	op             Op
	typ            string
	id             *string
	user_id        *string
	conn_id        *string
	refresh        *[]byte
	connector_data *[]byte
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*OfflineSession, error)
	predicates     []predicate.OfflineSession
}

var _ ent.Mutation = (*OfflineSessionMutation)(nil)

// offlinesessionOption allows management of the mutation configuration using functional options.
type offlinesessionOption func(*OfflineSessionMutation)

// newOfflineSessionMutation creates new mutation for the OfflineSession entity.
func newOfflineSessionMutation(c config, op Op, opts ...offlinesessionOption) *OfflineSessionMutation {
	m := &OfflineSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeOfflineSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOfflineSessionID sets the ID field of the mutation.
func withOfflineSessionID(id string) offlinesessionOption {
	return func(m *OfflineSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *OfflineSession
		)
		m.oldValue = func(ctx context.Context) (*OfflineSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OfflineSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOfflineSession sets the old OfflineSession of the mutation.
func withOfflineSession(node *OfflineSession) offlinesessionOption {
	return func(m *OfflineSessionMutation) {
		m.oldValue = func(context.Context) (*OfflineSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OfflineSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OfflineSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OfflineSession entities.
func (m *OfflineSessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OfflineSessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OfflineSessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OfflineSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OfflineSessionMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OfflineSessionMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OfflineSession entity.
// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OfflineSessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OfflineSessionMutation) ResetUserID() {
	m.user_id = nil
}

// SetConnID sets the "conn_id" field.
func (m *OfflineSessionMutation) SetConnID(s string) {
	m.conn_id = &s
}

// ConnID returns the value of the "conn_id" field in the mutation.
func (m *OfflineSessionMutation) ConnID() (r string, exists bool) {
	v := m.conn_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConnID returns the old "conn_id" field's value of the OfflineSession entity.
// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OfflineSessionMutation) OldConnID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnID: %w", err)
	}
	return oldValue.ConnID, nil
}

// ResetConnID resets all changes to the "conn_id" field.
func (m *OfflineSessionMutation) ResetConnID() {
	m.conn_id = nil
}

// SetRefresh sets the "refresh" field.
func (m *OfflineSessionMutation) SetRefresh(b []byte) {
	m.refresh = &b
}

// Refresh returns the value of the "refresh" field in the mutation.
func (m *OfflineSessionMutation) Refresh() (r []byte, exists bool) {
	v := m.refresh
	if v == nil {
		return
	}
	return *v, true
}

// OldRefresh returns the old "refresh" field's value of the OfflineSession entity.
// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OfflineSessionMutation) OldRefresh(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefresh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefresh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefresh: %w", err)
	}
	return oldValue.Refresh, nil
}

// ResetRefresh resets all changes to the "refresh" field.
func (m *OfflineSessionMutation) ResetRefresh() {
	m.refresh = nil
}

// SetConnectorData sets the "connector_data" field.
func (m *OfflineSessionMutation) SetConnectorData(b []byte) {
	m.connector_data = &b
}

// ConnectorData returns the value of the "connector_data" field in the mutation.
func (m *OfflineSessionMutation) ConnectorData() (r []byte, exists bool) {
	v := m.connector_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorData returns the old "connector_data" field's value of the OfflineSession entity.
// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OfflineSessionMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorData: %w", err)
	}
	return oldValue.ConnectorData, nil
}

// ClearConnectorData clears the value of the "connector_data" field.
func (m *OfflineSessionMutation) ClearConnectorData() {
	m.connector_data = nil
	m.clearedFields[offlinesession.FieldConnectorData] = struct{}{}
}

// ConnectorDataCleared returns if the "connector_data" field was cleared in this mutation.
func (m *OfflineSessionMutation) ConnectorDataCleared() bool {
	_, ok := m.clearedFields[offlinesession.FieldConnectorData]
	return ok
}

// ResetConnectorData resets all changes to the "connector_data" field.
func (m *OfflineSessionMutation) ResetConnectorData() {
	m.connector_data = nil
	delete(m.clearedFields, offlinesession.FieldConnectorData)
}

// Where appends a list predicates to the OfflineSessionMutation builder.
func (m *OfflineSessionMutation) Where(ps ...predicate.OfflineSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OfflineSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OfflineSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OfflineSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OfflineSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OfflineSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OfflineSession).
func (m *OfflineSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OfflineSessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_id != nil {
		fields = append(fields, offlinesession.FieldUserID)
	}
	if m.conn_id != nil {
		fields = append(fields, offlinesession.FieldConnID)
	}
	if m.refresh != nil {
		fields = append(fields, offlinesession.FieldRefresh)
	}
	if m.connector_data != nil {
		fields = append(fields, offlinesession.FieldConnectorData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OfflineSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case offlinesession.FieldUserID:
		return m.UserID()
	case offlinesession.FieldConnID:
		return m.ConnID()
	case offlinesession.FieldRefresh:
		return m.Refresh()
	case offlinesession.FieldConnectorData:
		return m.ConnectorData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OfflineSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case offlinesession.FieldUserID:
		return m.OldUserID(ctx)
	case offlinesession.FieldConnID:
		return m.OldConnID(ctx)
	case offlinesession.FieldRefresh:
		return m.OldRefresh(ctx)
	case offlinesession.FieldConnectorData:
		return m.OldConnectorData(ctx)
	}
	return nil, fmt.Errorf("unknown OfflineSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OfflineSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case offlinesession.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case offlinesession.FieldConnID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnID(v)
		return nil
	case offlinesession.FieldRefresh:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefresh(v)
		return nil
	case offlinesession.FieldConnectorData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorData(v)
		return nil
	}
	return fmt.Errorf("unknown OfflineSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OfflineSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OfflineSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OfflineSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OfflineSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OfflineSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(offlinesession.FieldConnectorData) {
		fields = append(fields, offlinesession.FieldConnectorData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OfflineSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OfflineSessionMutation) ClearField(name string) error {
	switch name {
	case offlinesession.FieldConnectorData:
		m.ClearConnectorData()
		return nil
	}
	return fmt.Errorf("unknown OfflineSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OfflineSessionMutation) ResetField(name string) error {
	switch name {
	case offlinesession.FieldUserID:
		m.ResetUserID()
		return nil
	case offlinesession.FieldConnID:
		m.ResetConnID()
		return nil
	case offlinesession.FieldRefresh:
		m.ResetRefresh()
		return nil
	case offlinesession.FieldConnectorData:
		m.ResetConnectorData()
		return nil
	}
	return fmt.Errorf("unknown OfflineSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OfflineSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OfflineSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OfflineSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OfflineSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OfflineSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OfflineSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OfflineSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OfflineSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OfflineSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OfflineSession edge %s", name)
}

// PasswordMutation represents an operation that mutates the Password nodes in the graph.
type PasswordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	hash          *[]byte
	username      *string
	user_id       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Password, error)
	predicates    []predicate.Password
}

var _ ent.Mutation = (*PasswordMutation)(nil)

// passwordOption allows management of the mutation configuration using functional options.
type passwordOption func(*PasswordMutation)

// newPasswordMutation creates new mutation for the Password entity.
func newPasswordMutation(c config, op Op, opts ...passwordOption) *PasswordMutation {
	m := &PasswordMutation{
		config:        c,
		op:            op,
		typ:           TypePassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordID sets the ID field of the mutation.
func withPasswordID(id int) passwordOption {
	return func(m *PasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *Password
		)
		m.oldValue = func(ctx context.Context) (*Password, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Password.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPassword sets the old Password of the mutation.
func withPassword(node *Password) passwordOption {
	return func(m *PasswordMutation) {
		m.oldValue = func(context.Context) (*Password, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Password.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *PasswordMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PasswordMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PasswordMutation) ResetEmail() {
	m.email = nil
}

// SetHash sets the "hash" field.
func (m *PasswordMutation) SetHash(b []byte) {
	m.hash = &b
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PasswordMutation) Hash() (r []byte, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PasswordMutation) ResetHash() {
	m.hash = nil
}

// SetUsername sets the "username" field.
func (m *PasswordMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *PasswordMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *PasswordMutation) ResetUsername() {
	m.username = nil
}

// SetUserID sets the "user_id" field.
func (m *PasswordMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasswordMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Password entity.
// If the Password object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasswordMutation) ResetUserID() {
	m.user_id = nil
}

// Where appends a list predicates to the PasswordMutation builder.
func (m *PasswordMutation) Where(ps ...predicate.Password) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Password, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Password).
func (m *PasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, password.FieldEmail)
	}
	if m.hash != nil {
		fields = append(fields, password.FieldHash)
	}
	if m.username != nil {
		fields = append(fields, password.FieldUsername)
	}
	if m.user_id != nil {
		fields = append(fields, password.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case password.FieldEmail:
		return m.Email()
	case password.FieldHash:
		return m.Hash()
	case password.FieldUsername:
		return m.Username()
	case password.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case password.FieldEmail:
		return m.OldEmail(ctx)
	case password.FieldHash:
		return m.OldHash(ctx)
	case password.FieldUsername:
		return m.OldUsername(ctx)
	case password.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Password field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case password.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case password.FieldHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case password.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case password.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Password numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Password nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordMutation) ResetField(name string) error {
	switch name {
	case password.FieldEmail:
		m.ResetEmail()
		return nil
	case password.FieldHash:
		m.ResetHash()
		return nil
	case password.FieldUsername:
		m.ResetUsername()
		return nil
	case password.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Password field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Password unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Password edge %s", name)
}

// PlatformAppRoleMutation represents an operation that mutates the PlatformAppRole nodes in the graph.
type PlatformAppRoleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	app_id                      *string
	title                       *string
	description                 *string
	weight                      *int
	addweight                   *int
	is_active                   *bool
	clearedFields               map[string]struct{}
	user_assignments            map[int]struct{}
	removeduser_assignments     map[int]struct{}
	cleareduser_assignments     bool
	identity_assignments        map[int]struct{}
	removedidentity_assignments map[int]struct{}
	clearedidentity_assignments bool
	tokens                      map[int]struct{}
	removedtokens               map[int]struct{}
	clearedtokens               bool
	done                        bool
	oldValue                    func(context.Context) (*PlatformAppRole, error)
	predicates                  []predicate.PlatformAppRole
}

var _ ent.Mutation = (*PlatformAppRoleMutation)(nil)

// platformapproleOption allows management of the mutation configuration using functional options.
type platformapproleOption func(*PlatformAppRoleMutation)

// newPlatformAppRoleMutation creates new mutation for the PlatformAppRole entity.
func newPlatformAppRoleMutation(c config, op Op, opts ...platformapproleOption) *PlatformAppRoleMutation {
	m := &PlatformAppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformAppRoleID sets the ID field of the mutation.
func withPlatformAppRoleID(id int) platformapproleOption {
	return func(m *PlatformAppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformAppRole
		)
		m.oldValue = func(ctx context.Context) (*PlatformAppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformAppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformAppRole sets the old PlatformAppRole of the mutation.
func withPlatformAppRole(node *PlatformAppRole) platformapproleOption {
	return func(m *PlatformAppRoleMutation) {
		m.oldValue = func(context.Context) (*PlatformAppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformAppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformAppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformAppRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformAppRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformAppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PlatformAppRoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PlatformAppRoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PlatformAppRole entity.
// If the PlatformAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAppRoleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PlatformAppRoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PlatformAppRoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PlatformAppRoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PlatformAppRole entity.
// If the PlatformAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAppRoleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PlatformAppRoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAppID sets the "app_id" field.
func (m *PlatformAppRoleMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PlatformAppRoleMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the PlatformAppRole entity.
// If the PlatformAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAppRoleMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PlatformAppRoleMutation) ResetAppID() {
	m.app_id = nil
}

// SetTitle sets the "title" field.
func (m *PlatformAppRoleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PlatformAppRoleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PlatformAppRole entity.
// If the PlatformAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAppRoleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PlatformAppRoleMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *PlatformAppRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlatformAppRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlatformAppRole entity.
// If the PlatformAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAppRoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlatformAppRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[platformapprole.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlatformAppRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[platformapprole.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlatformAppRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, platformapprole.FieldDescription)
}

// SetWeight sets the "weight" field.
func (m *PlatformAppRoleMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PlatformAppRoleMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the PlatformAppRole entity.
// If the PlatformAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAppRoleMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *PlatformAppRoleMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *PlatformAppRoleMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *PlatformAppRoleMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetIsActive sets the "is_active" field.
func (m *PlatformAppRoleMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlatformAppRoleMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PlatformAppRole entity.
// If the PlatformAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformAppRoleMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlatformAppRoleMutation) ResetIsActive() {
	m.is_active = nil
}

// AddUserAssignmentIDs adds the "user_assignments" edge to the PlatformUserRoleAssignment entity by ids.
func (m *PlatformAppRoleMutation) AddUserAssignmentIDs(ids ...int) {
	if m.user_assignments == nil {
		m.user_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.user_assignments[ids[i]] = struct{}{}
	}
}

// ClearUserAssignments clears the "user_assignments" edge to the PlatformUserRoleAssignment entity.
func (m *PlatformAppRoleMutation) ClearUserAssignments() {
	m.cleareduser_assignments = true
}

// UserAssignmentsCleared reports if the "user_assignments" edge to the PlatformUserRoleAssignment entity was cleared.
func (m *PlatformAppRoleMutation) UserAssignmentsCleared() bool {
	return m.cleareduser_assignments
}

// RemoveUserAssignmentIDs removes the "user_assignments" edge to the PlatformUserRoleAssignment entity by IDs.
func (m *PlatformAppRoleMutation) RemoveUserAssignmentIDs(ids ...int) {
	if m.removeduser_assignments == nil {
		m.removeduser_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_assignments, ids[i])
		m.removeduser_assignments[ids[i]] = struct{}{}
	}
}

// RemovedUserAssignments returns the removed IDs of the "user_assignments" edge to the PlatformUserRoleAssignment entity.
func (m *PlatformAppRoleMutation) RemovedUserAssignmentsIDs() (ids []int) {
	for id := range m.removeduser_assignments {
		ids = append(ids, id)
	}
	return
}

// UserAssignmentsIDs returns the "user_assignments" edge IDs in the mutation.
func (m *PlatformAppRoleMutation) UserAssignmentsIDs() (ids []int) {
	for id := range m.user_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetUserAssignments resets all changes to the "user_assignments" edge.
func (m *PlatformAppRoleMutation) ResetUserAssignments() {
	m.user_assignments = nil
	m.cleareduser_assignments = false
	m.removeduser_assignments = nil
}

// AddIdentityAssignmentIDs adds the "identity_assignments" edge to the PlatformIdentityRoleAssignment entity by ids.
func (m *PlatformAppRoleMutation) AddIdentityAssignmentIDs(ids ...int) {
	if m.identity_assignments == nil {
		m.identity_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.identity_assignments[ids[i]] = struct{}{}
	}
}

// ClearIdentityAssignments clears the "identity_assignments" edge to the PlatformIdentityRoleAssignment entity.
func (m *PlatformAppRoleMutation) ClearIdentityAssignments() {
	m.clearedidentity_assignments = true
}

// IdentityAssignmentsCleared reports if the "identity_assignments" edge to the PlatformIdentityRoleAssignment entity was cleared.
func (m *PlatformAppRoleMutation) IdentityAssignmentsCleared() bool {
	return m.clearedidentity_assignments
}

// RemoveIdentityAssignmentIDs removes the "identity_assignments" edge to the PlatformIdentityRoleAssignment entity by IDs.
func (m *PlatformAppRoleMutation) RemoveIdentityAssignmentIDs(ids ...int) {
	if m.removedidentity_assignments == nil {
		m.removedidentity_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identity_assignments, ids[i])
		m.removedidentity_assignments[ids[i]] = struct{}{}
	}
}

// RemovedIdentityAssignments returns the removed IDs of the "identity_assignments" edge to the PlatformIdentityRoleAssignment entity.
func (m *PlatformAppRoleMutation) RemovedIdentityAssignmentsIDs() (ids []int) {
	for id := range m.removedidentity_assignments {
		ids = append(ids, id)
	}
	return
}

// IdentityAssignmentsIDs returns the "identity_assignments" edge IDs in the mutation.
func (m *PlatformAppRoleMutation) IdentityAssignmentsIDs() (ids []int) {
	for id := range m.identity_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetIdentityAssignments resets all changes to the "identity_assignments" edge.
func (m *PlatformAppRoleMutation) ResetIdentityAssignments() {
	m.identity_assignments = nil
	m.clearedidentity_assignments = false
	m.removedidentity_assignments = nil
}

// AddTokenIDs adds the "tokens" edge to the PlatformToken entity by ids.
func (m *PlatformAppRoleMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the PlatformToken entity.
func (m *PlatformAppRoleMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the PlatformToken entity was cleared.
func (m *PlatformAppRoleMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the PlatformToken entity by IDs.
func (m *PlatformAppRoleMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the PlatformToken entity.
func (m *PlatformAppRoleMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *PlatformAppRoleMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *PlatformAppRoleMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// Where appends a list predicates to the PlatformAppRoleMutation builder.
func (m *PlatformAppRoleMutation) Where(ps ...predicate.PlatformAppRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformAppRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformAppRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformAppRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformAppRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformAppRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformAppRole).
func (m *PlatformAppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformAppRoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, platformapprole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, platformapprole.FieldUpdateTime)
	}
	if m.app_id != nil {
		fields = append(fields, platformapprole.FieldAppID)
	}
	if m.title != nil {
		fields = append(fields, platformapprole.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, platformapprole.FieldDescription)
	}
	if m.weight != nil {
		fields = append(fields, platformapprole.FieldWeight)
	}
	if m.is_active != nil {
		fields = append(fields, platformapprole.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformAppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformapprole.FieldCreateTime:
		return m.CreateTime()
	case platformapprole.FieldUpdateTime:
		return m.UpdateTime()
	case platformapprole.FieldAppID:
		return m.AppID()
	case platformapprole.FieldTitle:
		return m.Title()
	case platformapprole.FieldDescription:
		return m.Description()
	case platformapprole.FieldWeight:
		return m.Weight()
	case platformapprole.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformAppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformapprole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case platformapprole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case platformapprole.FieldAppID:
		return m.OldAppID(ctx)
	case platformapprole.FieldTitle:
		return m.OldTitle(ctx)
	case platformapprole.FieldDescription:
		return m.OldDescription(ctx)
	case platformapprole.FieldWeight:
		return m.OldWeight(ctx)
	case platformapprole.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformAppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformapprole.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case platformapprole.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case platformapprole.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case platformapprole.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case platformapprole.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case platformapprole.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case platformapprole.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformAppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, platformapprole.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformAppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case platformapprole.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformAppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case platformapprole.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformAppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformAppRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(platformapprole.FieldDescription) {
		fields = append(fields, platformapprole.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformAppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformAppRoleMutation) ClearField(name string) error {
	switch name {
	case platformapprole.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PlatformAppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformAppRoleMutation) ResetField(name string) error {
	switch name {
	case platformapprole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case platformapprole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case platformapprole.FieldAppID:
		m.ResetAppID()
		return nil
	case platformapprole.FieldTitle:
		m.ResetTitle()
		return nil
	case platformapprole.FieldDescription:
		m.ResetDescription()
		return nil
	case platformapprole.FieldWeight:
		m.ResetWeight()
		return nil
	case platformapprole.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown PlatformAppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformAppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user_assignments != nil {
		edges = append(edges, platformapprole.EdgeUserAssignments)
	}
	if m.identity_assignments != nil {
		edges = append(edges, platformapprole.EdgeIdentityAssignments)
	}
	if m.tokens != nil {
		edges = append(edges, platformapprole.EdgeTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformAppRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformapprole.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.user_assignments))
		for id := range m.user_assignments {
			ids = append(ids, id)
		}
		return ids
	case platformapprole.EdgeIdentityAssignments:
		ids := make([]ent.Value, 0, len(m.identity_assignments))
		for id := range m.identity_assignments {
			ids = append(ids, id)
		}
		return ids
	case platformapprole.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformAppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_assignments != nil {
		edges = append(edges, platformapprole.EdgeUserAssignments)
	}
	if m.removedidentity_assignments != nil {
		edges = append(edges, platformapprole.EdgeIdentityAssignments)
	}
	if m.removedtokens != nil {
		edges = append(edges, platformapprole.EdgeTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformAppRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platformapprole.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.removeduser_assignments))
		for id := range m.removeduser_assignments {
			ids = append(ids, id)
		}
		return ids
	case platformapprole.EdgeIdentityAssignments:
		ids := make([]ent.Value, 0, len(m.removedidentity_assignments))
		for id := range m.removedidentity_assignments {
			ids = append(ids, id)
		}
		return ids
	case platformapprole.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformAppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser_assignments {
		edges = append(edges, platformapprole.EdgeUserAssignments)
	}
	if m.clearedidentity_assignments {
		edges = append(edges, platformapprole.EdgeIdentityAssignments)
	}
	if m.clearedtokens {
		edges = append(edges, platformapprole.EdgeTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformAppRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case platformapprole.EdgeUserAssignments:
		return m.cleareduser_assignments
	case platformapprole.EdgeIdentityAssignments:
		return m.clearedidentity_assignments
	case platformapprole.EdgeTokens:
		return m.clearedtokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformAppRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformAppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformAppRoleMutation) ResetEdge(name string) error {
	switch name {
	case platformapprole.EdgeUserAssignments:
		m.ResetUserAssignments()
		return nil
	case platformapprole.EdgeIdentityAssignments:
		m.ResetIdentityAssignments()
		return nil
	case platformapprole.EdgeTokens:
		m.ResetTokens()
		return nil
	}
	return fmt.Errorf("unknown PlatformAppRole edge %s", name)
}

// PlatformFederatedIdentityMutation represents an operation that mutates the PlatformFederatedIdentity nodes in the graph.
type PlatformFederatedIdentityMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	connector_id            *string
	federated_user_id       *string
	clearedFields           map[string]struct{}
	user                    *int
	cleareduser             bool
	role_assignments        map[int]struct{}
	removedrole_assignments map[int]struct{}
	clearedrole_assignments bool
	done                    bool
	oldValue                func(context.Context) (*PlatformFederatedIdentity, error)
	predicates              []predicate.PlatformFederatedIdentity
}

var _ ent.Mutation = (*PlatformFederatedIdentityMutation)(nil)

// platformfederatedidentityOption allows management of the mutation configuration using functional options.
type platformfederatedidentityOption func(*PlatformFederatedIdentityMutation)

// newPlatformFederatedIdentityMutation creates new mutation for the PlatformFederatedIdentity entity.
func newPlatformFederatedIdentityMutation(c config, op Op, opts ...platformfederatedidentityOption) *PlatformFederatedIdentityMutation {
	m := &PlatformFederatedIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformFederatedIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformFederatedIdentityID sets the ID field of the mutation.
func withPlatformFederatedIdentityID(id int) platformfederatedidentityOption {
	return func(m *PlatformFederatedIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformFederatedIdentity
		)
		m.oldValue = func(ctx context.Context) (*PlatformFederatedIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformFederatedIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformFederatedIdentity sets the old PlatformFederatedIdentity of the mutation.
func withPlatformFederatedIdentity(node *PlatformFederatedIdentity) platformfederatedidentityOption {
	return func(m *PlatformFederatedIdentityMutation) {
		m.oldValue = func(context.Context) (*PlatformFederatedIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformFederatedIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformFederatedIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformFederatedIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformFederatedIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformFederatedIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PlatformFederatedIdentityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PlatformFederatedIdentityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PlatformFederatedIdentity entity.
// If the PlatformFederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformFederatedIdentityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PlatformFederatedIdentityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PlatformFederatedIdentityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PlatformFederatedIdentityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PlatformFederatedIdentity entity.
// If the PlatformFederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformFederatedIdentityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PlatformFederatedIdentityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *PlatformFederatedIdentityMutation) SetConnectorID(s string) {
	m.connector_id = &s
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *PlatformFederatedIdentityMutation) ConnectorID() (r string, exists bool) {
	v := m.connector_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the PlatformFederatedIdentity entity.
// If the PlatformFederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformFederatedIdentityMutation) OldConnectorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *PlatformFederatedIdentityMutation) ResetConnectorID() {
	m.connector_id = nil
}

// SetFederatedUserID sets the "federated_user_id" field.
func (m *PlatformFederatedIdentityMutation) SetFederatedUserID(s string) {
	m.federated_user_id = &s
}

// FederatedUserID returns the value of the "federated_user_id" field in the mutation.
func (m *PlatformFederatedIdentityMutation) FederatedUserID() (r string, exists bool) {
	v := m.federated_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFederatedUserID returns the old "federated_user_id" field's value of the PlatformFederatedIdentity entity.
// If the PlatformFederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformFederatedIdentityMutation) OldFederatedUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFederatedUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFederatedUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFederatedUserID: %w", err)
	}
	return oldValue.FederatedUserID, nil
}

// ResetFederatedUserID resets all changes to the "federated_user_id" field.
func (m *PlatformFederatedIdentityMutation) ResetFederatedUserID() {
	m.federated_user_id = nil
}

// SetUserID sets the "user" edge to the PlatformUser entity by id.
func (m *PlatformFederatedIdentityMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the PlatformUser entity.
func (m *PlatformFederatedIdentityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the PlatformUser entity was cleared.
func (m *PlatformFederatedIdentityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PlatformFederatedIdentityMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PlatformFederatedIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PlatformFederatedIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddRoleAssignmentIDs adds the "role_assignments" edge to the PlatformIdentityRoleAssignment entity by ids.
func (m *PlatformFederatedIdentityMutation) AddRoleAssignmentIDs(ids ...int) {
	if m.role_assignments == nil {
		m.role_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.role_assignments[ids[i]] = struct{}{}
	}
}

// ClearRoleAssignments clears the "role_assignments" edge to the PlatformIdentityRoleAssignment entity.
func (m *PlatformFederatedIdentityMutation) ClearRoleAssignments() {
	m.clearedrole_assignments = true
}

// RoleAssignmentsCleared reports if the "role_assignments" edge to the PlatformIdentityRoleAssignment entity was cleared.
func (m *PlatformFederatedIdentityMutation) RoleAssignmentsCleared() bool {
	return m.clearedrole_assignments
}

// RemoveRoleAssignmentIDs removes the "role_assignments" edge to the PlatformIdentityRoleAssignment entity by IDs.
func (m *PlatformFederatedIdentityMutation) RemoveRoleAssignmentIDs(ids ...int) {
	if m.removedrole_assignments == nil {
		m.removedrole_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_assignments, ids[i])
		m.removedrole_assignments[ids[i]] = struct{}{}
	}
}

// RemovedRoleAssignments returns the removed IDs of the "role_assignments" edge to the PlatformIdentityRoleAssignment entity.
func (m *PlatformFederatedIdentityMutation) RemovedRoleAssignmentsIDs() (ids []int) {
	for id := range m.removedrole_assignments {
		ids = append(ids, id)
	}
	return
}

// RoleAssignmentsIDs returns the "role_assignments" edge IDs in the mutation.
func (m *PlatformFederatedIdentityMutation) RoleAssignmentsIDs() (ids []int) {
	for id := range m.role_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetRoleAssignments resets all changes to the "role_assignments" edge.
func (m *PlatformFederatedIdentityMutation) ResetRoleAssignments() {
	m.role_assignments = nil
	m.clearedrole_assignments = false
	m.removedrole_assignments = nil
}

// Where appends a list predicates to the PlatformFederatedIdentityMutation builder.
func (m *PlatformFederatedIdentityMutation) Where(ps ...predicate.PlatformFederatedIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformFederatedIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformFederatedIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformFederatedIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformFederatedIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformFederatedIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformFederatedIdentity).
func (m *PlatformFederatedIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformFederatedIdentityMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, platformfederatedidentity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, platformfederatedidentity.FieldUpdateTime)
	}
	if m.connector_id != nil {
		fields = append(fields, platformfederatedidentity.FieldConnectorID)
	}
	if m.federated_user_id != nil {
		fields = append(fields, platformfederatedidentity.FieldFederatedUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformFederatedIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformfederatedidentity.FieldCreateTime:
		return m.CreateTime()
	case platformfederatedidentity.FieldUpdateTime:
		return m.UpdateTime()
	case platformfederatedidentity.FieldConnectorID:
		return m.ConnectorID()
	case platformfederatedidentity.FieldFederatedUserID:
		return m.FederatedUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformFederatedIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformfederatedidentity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case platformfederatedidentity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case platformfederatedidentity.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case platformfederatedidentity.FieldFederatedUserID:
		return m.OldFederatedUserID(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformFederatedIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformFederatedIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformfederatedidentity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case platformfederatedidentity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case platformfederatedidentity.FieldConnectorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case platformfederatedidentity.FieldFederatedUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFederatedUserID(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformFederatedIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformFederatedIdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformFederatedIdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformFederatedIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformFederatedIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformFederatedIdentityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformFederatedIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformFederatedIdentityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlatformFederatedIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformFederatedIdentityMutation) ResetField(name string) error {
	switch name {
	case platformfederatedidentity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case platformfederatedidentity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case platformfederatedidentity.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case platformfederatedidentity.FieldFederatedUserID:
		m.ResetFederatedUserID()
		return nil
	}
	return fmt.Errorf("unknown PlatformFederatedIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformFederatedIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, platformfederatedidentity.EdgeUser)
	}
	if m.role_assignments != nil {
		edges = append(edges, platformfederatedidentity.EdgeRoleAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformFederatedIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformfederatedidentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case platformfederatedidentity.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.role_assignments))
		for id := range m.role_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformFederatedIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrole_assignments != nil {
		edges = append(edges, platformfederatedidentity.EdgeRoleAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformFederatedIdentityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platformfederatedidentity.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.removedrole_assignments))
		for id := range m.removedrole_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformFederatedIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, platformfederatedidentity.EdgeUser)
	}
	if m.clearedrole_assignments {
		edges = append(edges, platformfederatedidentity.EdgeRoleAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformFederatedIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case platformfederatedidentity.EdgeUser:
		return m.cleareduser
	case platformfederatedidentity.EdgeRoleAssignments:
		return m.clearedrole_assignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformFederatedIdentityMutation) ClearEdge(name string) error {
	switch name {
	case platformfederatedidentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PlatformFederatedIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformFederatedIdentityMutation) ResetEdge(name string) error {
	switch name {
	case platformfederatedidentity.EdgeUser:
		m.ResetUser()
		return nil
	case platformfederatedidentity.EdgeRoleAssignments:
		m.ResetRoleAssignments()
		return nil
	}
	return fmt.Errorf("unknown PlatformFederatedIdentity edge %s", name)
}

// PlatformIdentityRoleAssignmentMutation represents an operation that mutates the PlatformIdentityRoleAssignment nodes in the graph.
type PlatformIdentityRoleAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	update_time     *time.Time
	is_active       *bool
	assigned_at     *time.Time
	clearedFields   map[string]struct{}
	identity        *int
	clearedidentity bool
	role            *int
	clearedrole     bool
	done            bool
	oldValue        func(context.Context) (*PlatformIdentityRoleAssignment, error)
	predicates      []predicate.PlatformIdentityRoleAssignment
}

var _ ent.Mutation = (*PlatformIdentityRoleAssignmentMutation)(nil)

// platformidentityroleassignmentOption allows management of the mutation configuration using functional options.
type platformidentityroleassignmentOption func(*PlatformIdentityRoleAssignmentMutation)

// newPlatformIdentityRoleAssignmentMutation creates new mutation for the PlatformIdentityRoleAssignment entity.
func newPlatformIdentityRoleAssignmentMutation(c config, op Op, opts ...platformidentityroleassignmentOption) *PlatformIdentityRoleAssignmentMutation {
	m := &PlatformIdentityRoleAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformIdentityRoleAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformIdentityRoleAssignmentID sets the ID field of the mutation.
func withPlatformIdentityRoleAssignmentID(id int) platformidentityroleassignmentOption {
	return func(m *PlatformIdentityRoleAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformIdentityRoleAssignment
		)
		m.oldValue = func(ctx context.Context) (*PlatformIdentityRoleAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformIdentityRoleAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformIdentityRoleAssignment sets the old PlatformIdentityRoleAssignment of the mutation.
func withPlatformIdentityRoleAssignment(node *PlatformIdentityRoleAssignment) platformidentityroleassignmentOption {
	return func(m *PlatformIdentityRoleAssignmentMutation) {
		m.oldValue = func(context.Context) (*PlatformIdentityRoleAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformIdentityRoleAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformIdentityRoleAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformIdentityRoleAssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformIdentityRoleAssignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformIdentityRoleAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *PlatformIdentityRoleAssignmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PlatformIdentityRoleAssignmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PlatformIdentityRoleAssignment entity.
// If the PlatformIdentityRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformIdentityRoleAssignmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PlatformIdentityRoleAssignmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIsActive sets the "is_active" field.
func (m *PlatformIdentityRoleAssignmentMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlatformIdentityRoleAssignmentMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PlatformIdentityRoleAssignment entity.
// If the PlatformIdentityRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformIdentityRoleAssignmentMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlatformIdentityRoleAssignmentMutation) ResetIsActive() {
	m.is_active = nil
}

// SetAssignedAt sets the "assigned_at" field.
func (m *PlatformIdentityRoleAssignmentMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *PlatformIdentityRoleAssignmentMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the PlatformIdentityRoleAssignment entity.
// If the PlatformIdentityRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformIdentityRoleAssignmentMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *PlatformIdentityRoleAssignmentMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetIdentityID sets the "identity" edge to the PlatformFederatedIdentity entity by id.
func (m *PlatformIdentityRoleAssignmentMutation) SetIdentityID(id int) {
	m.identity = &id
}

// ClearIdentity clears the "identity" edge to the PlatformFederatedIdentity entity.
func (m *PlatformIdentityRoleAssignmentMutation) ClearIdentity() {
	m.clearedidentity = true
}

// IdentityCleared reports if the "identity" edge to the PlatformFederatedIdentity entity was cleared.
func (m *PlatformIdentityRoleAssignmentMutation) IdentityCleared() bool {
	return m.clearedidentity
}

// IdentityID returns the "identity" edge ID in the mutation.
func (m *PlatformIdentityRoleAssignmentMutation) IdentityID() (id int, exists bool) {
	if m.identity != nil {
		return *m.identity, true
	}
	return
}

// IdentityIDs returns the "identity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IdentityID instead. It exists only for internal usage by the builders.
func (m *PlatformIdentityRoleAssignmentMutation) IdentityIDs() (ids []int) {
	if id := m.identity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIdentity resets all changes to the "identity" edge.
func (m *PlatformIdentityRoleAssignmentMutation) ResetIdentity() {
	m.identity = nil
	m.clearedidentity = false
}

// SetRoleID sets the "role" edge to the PlatformAppRole entity by id.
func (m *PlatformIdentityRoleAssignmentMutation) SetRoleID(id int) {
	m.role = &id
}

// ClearRole clears the "role" edge to the PlatformAppRole entity.
func (m *PlatformIdentityRoleAssignmentMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the PlatformAppRole entity was cleared.
func (m *PlatformIdentityRoleAssignmentMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *PlatformIdentityRoleAssignmentMutation) RoleID() (id int, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *PlatformIdentityRoleAssignmentMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *PlatformIdentityRoleAssignmentMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the PlatformIdentityRoleAssignmentMutation builder.
func (m *PlatformIdentityRoleAssignmentMutation) Where(ps ...predicate.PlatformIdentityRoleAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformIdentityRoleAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformIdentityRoleAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformIdentityRoleAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformIdentityRoleAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformIdentityRoleAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformIdentityRoleAssignment).
func (m *PlatformIdentityRoleAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformIdentityRoleAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.update_time != nil {
		fields = append(fields, platformidentityroleassignment.FieldUpdateTime)
	}
	if m.is_active != nil {
		fields = append(fields, platformidentityroleassignment.FieldIsActive)
	}
	if m.assigned_at != nil {
		fields = append(fields, platformidentityroleassignment.FieldAssignedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformIdentityRoleAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformidentityroleassignment.FieldUpdateTime:
		return m.UpdateTime()
	case platformidentityroleassignment.FieldIsActive:
		return m.IsActive()
	case platformidentityroleassignment.FieldAssignedAt:
		return m.AssignedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformIdentityRoleAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformidentityroleassignment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case platformidentityroleassignment.FieldIsActive:
		return m.OldIsActive(ctx)
	case platformidentityroleassignment.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformIdentityRoleAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformIdentityRoleAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformidentityroleassignment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case platformidentityroleassignment.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case platformidentityroleassignment.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformIdentityRoleAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformIdentityRoleAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformIdentityRoleAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformIdentityRoleAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformIdentityRoleAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformIdentityRoleAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlatformIdentityRoleAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformIdentityRoleAssignmentMutation) ResetField(name string) error {
	switch name {
	case platformidentityroleassignment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case platformidentityroleassignment.FieldIsActive:
		m.ResetIsActive()
		return nil
	case platformidentityroleassignment.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	}
	return fmt.Errorf("unknown PlatformIdentityRoleAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.identity != nil {
		edges = append(edges, platformidentityroleassignment.EdgeIdentity)
	}
	if m.role != nil {
		edges = append(edges, platformidentityroleassignment.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformidentityroleassignment.EdgeIdentity:
		if id := m.identity; id != nil {
			return []ent.Value{*id}
		}
	case platformidentityroleassignment.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedidentity {
		edges = append(edges, platformidentityroleassignment.EdgeIdentity)
	}
	if m.clearedrole {
		edges = append(edges, platformidentityroleassignment.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformIdentityRoleAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case platformidentityroleassignment.EdgeIdentity:
		return m.clearedidentity
	case platformidentityroleassignment.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformIdentityRoleAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case platformidentityroleassignment.EdgeIdentity:
		m.ClearIdentity()
		return nil
	case platformidentityroleassignment.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown PlatformIdentityRoleAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformIdentityRoleAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case platformidentityroleassignment.EdgeIdentity:
		m.ResetIdentity()
		return nil
	case platformidentityroleassignment.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown PlatformIdentityRoleAssignment edge %s", name)
}

// PlatformTokenMutation represents an operation that mutates the PlatformToken nodes in the graph.
type PlatformTokenMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	public_id      *string
	secret_hash    *string
	is_active      *bool
	expires_at     *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	role           *int
	clearedrole    bool
	done           bool
	oldValue       func(context.Context) (*PlatformToken, error)
	predicates     []predicate.PlatformToken
}

var _ ent.Mutation = (*PlatformTokenMutation)(nil)

// platformtokenOption allows management of the mutation configuration using functional options.
type platformtokenOption func(*PlatformTokenMutation)

// newPlatformTokenMutation creates new mutation for the PlatformToken entity.
func newPlatformTokenMutation(c config, op Op, opts ...platformtokenOption) *PlatformTokenMutation {
	m := &PlatformTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformTokenID sets the ID field of the mutation.
func withPlatformTokenID(id int) platformtokenOption {
	return func(m *PlatformTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformToken
		)
		m.oldValue = func(ctx context.Context) (*PlatformToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformToken sets the old PlatformToken of the mutation.
func withPlatformToken(node *PlatformToken) platformtokenOption {
	return func(m *PlatformTokenMutation) {
		m.oldValue = func(context.Context) (*PlatformToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PlatformTokenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PlatformTokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PlatformToken entity.
// If the PlatformToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformTokenMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PlatformTokenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PlatformTokenMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PlatformTokenMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PlatformToken entity.
// If the PlatformToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformTokenMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PlatformTokenMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPublicID sets the "public_id" field.
func (m *PlatformTokenMutation) SetPublicID(s string) {
	m.public_id = &s
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *PlatformTokenMutation) PublicID() (r string, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the PlatformToken entity.
// If the PlatformToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformTokenMutation) OldPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *PlatformTokenMutation) ResetPublicID() {
	m.public_id = nil
}

// SetSecretHash sets the "secret_hash" field.
func (m *PlatformTokenMutation) SetSecretHash(s string) {
	m.secret_hash = &s
}

// SecretHash returns the value of the "secret_hash" field in the mutation.
func (m *PlatformTokenMutation) SecretHash() (r string, exists bool) {
	v := m.secret_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretHash returns the old "secret_hash" field's value of the PlatformToken entity.
// If the PlatformToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformTokenMutation) OldSecretHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretHash: %w", err)
	}
	return oldValue.SecretHash, nil
}

// ResetSecretHash resets all changes to the "secret_hash" field.
func (m *PlatformTokenMutation) ResetSecretHash() {
	m.secret_hash = nil
}

// SetIsActive sets the "is_active" field.
func (m *PlatformTokenMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlatformTokenMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PlatformToken entity.
// If the PlatformToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformTokenMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlatformTokenMutation) ResetIsActive() {
	m.is_active = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PlatformTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PlatformTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PlatformToken entity.
// If the PlatformToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformTokenMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *PlatformTokenMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[platformtoken.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *PlatformTokenMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[platformtoken.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PlatformTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, platformtoken.FieldExpiresAt)
}

// SetCreatorID sets the "creator" edge to the PlatformUser entity by id.
func (m *PlatformTokenMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the PlatformUser entity.
func (m *PlatformTokenMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the PlatformUser entity was cleared.
func (m *PlatformTokenMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *PlatformTokenMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *PlatformTokenMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *PlatformTokenMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetRoleID sets the "role" edge to the PlatformAppRole entity by id.
func (m *PlatformTokenMutation) SetRoleID(id int) {
	m.role = &id
}

// ClearRole clears the "role" edge to the PlatformAppRole entity.
func (m *PlatformTokenMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the PlatformAppRole entity was cleared.
func (m *PlatformTokenMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *PlatformTokenMutation) RoleID() (id int, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *PlatformTokenMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *PlatformTokenMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the PlatformTokenMutation builder.
func (m *PlatformTokenMutation) Where(ps ...predicate.PlatformToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformToken).
func (m *PlatformTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, platformtoken.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, platformtoken.FieldUpdateTime)
	}
	if m.public_id != nil {
		fields = append(fields, platformtoken.FieldPublicID)
	}
	if m.secret_hash != nil {
		fields = append(fields, platformtoken.FieldSecretHash)
	}
	if m.is_active != nil {
		fields = append(fields, platformtoken.FieldIsActive)
	}
	if m.expires_at != nil {
		fields = append(fields, platformtoken.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformtoken.FieldCreateTime:
		return m.CreateTime()
	case platformtoken.FieldUpdateTime:
		return m.UpdateTime()
	case platformtoken.FieldPublicID:
		return m.PublicID()
	case platformtoken.FieldSecretHash:
		return m.SecretHash()
	case platformtoken.FieldIsActive:
		return m.IsActive()
	case platformtoken.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformtoken.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case platformtoken.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case platformtoken.FieldPublicID:
		return m.OldPublicID(ctx)
	case platformtoken.FieldSecretHash:
		return m.OldSecretHash(ctx)
	case platformtoken.FieldIsActive:
		return m.OldIsActive(ctx)
	case platformtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformtoken.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case platformtoken.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case platformtoken.FieldPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case platformtoken.FieldSecretHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretHash(v)
		return nil
	case platformtoken.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case platformtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(platformtoken.FieldExpiresAt) {
		fields = append(fields, platformtoken.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformTokenMutation) ClearField(name string) error {
	switch name {
	case platformtoken.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown PlatformToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformTokenMutation) ResetField(name string) error {
	switch name {
	case platformtoken.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case platformtoken.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case platformtoken.FieldPublicID:
		m.ResetPublicID()
		return nil
	case platformtoken.FieldSecretHash:
		m.ResetSecretHash()
		return nil
	case platformtoken.FieldIsActive:
		m.ResetIsActive()
		return nil
	case platformtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown PlatformToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, platformtoken.EdgeCreator)
	}
	if m.role != nil {
		edges = append(edges, platformtoken.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformtoken.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case platformtoken.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, platformtoken.EdgeCreator)
	}
	if m.clearedrole {
		edges = append(edges, platformtoken.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case platformtoken.EdgeCreator:
		return m.clearedcreator
	case platformtoken.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformTokenMutation) ClearEdge(name string) error {
	switch name {
	case platformtoken.EdgeCreator:
		m.ClearCreator()
		return nil
	case platformtoken.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown PlatformToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformTokenMutation) ResetEdge(name string) error {
	switch name {
	case platformtoken.EdgeCreator:
		m.ResetCreator()
		return nil
	case platformtoken.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown PlatformToken edge %s", name)
}

// PlatformUserMutation represents an operation that mutates the PlatformUser nodes in the graph.
type PlatformUserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	email                        *string
	display_name                 *string
	is_active                    *bool
	last_login                   *time.Time
	clearedFields                map[string]struct{}
	user_role_assignments        map[int]struct{}
	removeduser_role_assignments map[int]struct{}
	cleareduser_role_assignments bool
	federated_identities         map[int]struct{}
	removedfederated_identities  map[int]struct{}
	clearedfederated_identities  bool
	created_tokens               map[int]struct{}
	removedcreated_tokens        map[int]struct{}
	clearedcreated_tokens        bool
	done                         bool
	oldValue                     func(context.Context) (*PlatformUser, error)
	predicates                   []predicate.PlatformUser
}

var _ ent.Mutation = (*PlatformUserMutation)(nil)

// platformuserOption allows management of the mutation configuration using functional options.
type platformuserOption func(*PlatformUserMutation)

// newPlatformUserMutation creates new mutation for the PlatformUser entity.
func newPlatformUserMutation(c config, op Op, opts ...platformuserOption) *PlatformUserMutation {
	m := &PlatformUserMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformUserID sets the ID field of the mutation.
func withPlatformUserID(id int) platformuserOption {
	return func(m *PlatformUserMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformUser
		)
		m.oldValue = func(ctx context.Context) (*PlatformUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformUser sets the old PlatformUser of the mutation.
func withPlatformUser(node *PlatformUser) platformuserOption {
	return func(m *PlatformUserMutation) {
		m.oldValue = func(context.Context) (*PlatformUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PlatformUserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PlatformUserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PlatformUser entity.
// If the PlatformUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PlatformUserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PlatformUserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PlatformUserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PlatformUser entity.
// If the PlatformUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PlatformUserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *PlatformUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PlatformUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the PlatformUser entity.
// If the PlatformUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PlatformUserMutation) ResetEmail() {
	m.email = nil
}

// SetDisplayName sets the "display_name" field.
func (m *PlatformUserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PlatformUserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the PlatformUser entity.
// If the PlatformUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PlatformUserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[platformuser.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PlatformUserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[platformuser.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PlatformUserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, platformuser.FieldDisplayName)
}

// SetIsActive sets the "is_active" field.
func (m *PlatformUserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlatformUserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PlatformUser entity.
// If the PlatformUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlatformUserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetLastLogin sets the "last_login" field.
func (m *PlatformUserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *PlatformUserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the PlatformUser entity.
// If the PlatformUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *PlatformUserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[platformuser.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *PlatformUserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[platformuser.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *PlatformUserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, platformuser.FieldLastLogin)
}

// AddUserRoleAssignmentIDs adds the "user_role_assignments" edge to the PlatformUserRoleAssignment entity by ids.
func (m *PlatformUserMutation) AddUserRoleAssignmentIDs(ids ...int) {
	if m.user_role_assignments == nil {
		m.user_role_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.user_role_assignments[ids[i]] = struct{}{}
	}
}

// ClearUserRoleAssignments clears the "user_role_assignments" edge to the PlatformUserRoleAssignment entity.
func (m *PlatformUserMutation) ClearUserRoleAssignments() {
	m.cleareduser_role_assignments = true
}

// UserRoleAssignmentsCleared reports if the "user_role_assignments" edge to the PlatformUserRoleAssignment entity was cleared.
func (m *PlatformUserMutation) UserRoleAssignmentsCleared() bool {
	return m.cleareduser_role_assignments
}

// RemoveUserRoleAssignmentIDs removes the "user_role_assignments" edge to the PlatformUserRoleAssignment entity by IDs.
func (m *PlatformUserMutation) RemoveUserRoleAssignmentIDs(ids ...int) {
	if m.removeduser_role_assignments == nil {
		m.removeduser_role_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_role_assignments, ids[i])
		m.removeduser_role_assignments[ids[i]] = struct{}{}
	}
}

// RemovedUserRoleAssignments returns the removed IDs of the "user_role_assignments" edge to the PlatformUserRoleAssignment entity.
func (m *PlatformUserMutation) RemovedUserRoleAssignmentsIDs() (ids []int) {
	for id := range m.removeduser_role_assignments {
		ids = append(ids, id)
	}
	return
}

// UserRoleAssignmentsIDs returns the "user_role_assignments" edge IDs in the mutation.
func (m *PlatformUserMutation) UserRoleAssignmentsIDs() (ids []int) {
	for id := range m.user_role_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoleAssignments resets all changes to the "user_role_assignments" edge.
func (m *PlatformUserMutation) ResetUserRoleAssignments() {
	m.user_role_assignments = nil
	m.cleareduser_role_assignments = false
	m.removeduser_role_assignments = nil
}

// AddFederatedIdentityIDs adds the "federated_identities" edge to the PlatformFederatedIdentity entity by ids.
func (m *PlatformUserMutation) AddFederatedIdentityIDs(ids ...int) {
	if m.federated_identities == nil {
		m.federated_identities = make(map[int]struct{})
	}
	for i := range ids {
		m.federated_identities[ids[i]] = struct{}{}
	}
}

// ClearFederatedIdentities clears the "federated_identities" edge to the PlatformFederatedIdentity entity.
func (m *PlatformUserMutation) ClearFederatedIdentities() {
	m.clearedfederated_identities = true
}

// FederatedIdentitiesCleared reports if the "federated_identities" edge to the PlatformFederatedIdentity entity was cleared.
func (m *PlatformUserMutation) FederatedIdentitiesCleared() bool {
	return m.clearedfederated_identities
}

// RemoveFederatedIdentityIDs removes the "federated_identities" edge to the PlatformFederatedIdentity entity by IDs.
func (m *PlatformUserMutation) RemoveFederatedIdentityIDs(ids ...int) {
	if m.removedfederated_identities == nil {
		m.removedfederated_identities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.federated_identities, ids[i])
		m.removedfederated_identities[ids[i]] = struct{}{}
	}
}

// RemovedFederatedIdentities returns the removed IDs of the "federated_identities" edge to the PlatformFederatedIdentity entity.
func (m *PlatformUserMutation) RemovedFederatedIdentitiesIDs() (ids []int) {
	for id := range m.removedfederated_identities {
		ids = append(ids, id)
	}
	return
}

// FederatedIdentitiesIDs returns the "federated_identities" edge IDs in the mutation.
func (m *PlatformUserMutation) FederatedIdentitiesIDs() (ids []int) {
	for id := range m.federated_identities {
		ids = append(ids, id)
	}
	return
}

// ResetFederatedIdentities resets all changes to the "federated_identities" edge.
func (m *PlatformUserMutation) ResetFederatedIdentities() {
	m.federated_identities = nil
	m.clearedfederated_identities = false
	m.removedfederated_identities = nil
}

// AddCreatedTokenIDs adds the "created_tokens" edge to the PlatformToken entity by ids.
func (m *PlatformUserMutation) AddCreatedTokenIDs(ids ...int) {
	if m.created_tokens == nil {
		m.created_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.created_tokens[ids[i]] = struct{}{}
	}
}

// ClearCreatedTokens clears the "created_tokens" edge to the PlatformToken entity.
func (m *PlatformUserMutation) ClearCreatedTokens() {
	m.clearedcreated_tokens = true
}

// CreatedTokensCleared reports if the "created_tokens" edge to the PlatformToken entity was cleared.
func (m *PlatformUserMutation) CreatedTokensCleared() bool {
	return m.clearedcreated_tokens
}

// RemoveCreatedTokenIDs removes the "created_tokens" edge to the PlatformToken entity by IDs.
func (m *PlatformUserMutation) RemoveCreatedTokenIDs(ids ...int) {
	if m.removedcreated_tokens == nil {
		m.removedcreated_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_tokens, ids[i])
		m.removedcreated_tokens[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTokens returns the removed IDs of the "created_tokens" edge to the PlatformToken entity.
func (m *PlatformUserMutation) RemovedCreatedTokensIDs() (ids []int) {
	for id := range m.removedcreated_tokens {
		ids = append(ids, id)
	}
	return
}

// CreatedTokensIDs returns the "created_tokens" edge IDs in the mutation.
func (m *PlatformUserMutation) CreatedTokensIDs() (ids []int) {
	for id := range m.created_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTokens resets all changes to the "created_tokens" edge.
func (m *PlatformUserMutation) ResetCreatedTokens() {
	m.created_tokens = nil
	m.clearedcreated_tokens = false
	m.removedcreated_tokens = nil
}

// Where appends a list predicates to the PlatformUserMutation builder.
func (m *PlatformUserMutation) Where(ps ...predicate.PlatformUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformUser).
func (m *PlatformUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, platformuser.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, platformuser.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, platformuser.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, platformuser.FieldDisplayName)
	}
	if m.is_active != nil {
		fields = append(fields, platformuser.FieldIsActive)
	}
	if m.last_login != nil {
		fields = append(fields, platformuser.FieldLastLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformuser.FieldCreateTime:
		return m.CreateTime()
	case platformuser.FieldUpdateTime:
		return m.UpdateTime()
	case platformuser.FieldEmail:
		return m.Email()
	case platformuser.FieldDisplayName:
		return m.DisplayName()
	case platformuser.FieldIsActive:
		return m.IsActive()
	case platformuser.FieldLastLogin:
		return m.LastLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformuser.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case platformuser.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case platformuser.FieldEmail:
		return m.OldEmail(ctx)
	case platformuser.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case platformuser.FieldIsActive:
		return m.OldIsActive(ctx)
	case platformuser.FieldLastLogin:
		return m.OldLastLogin(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformuser.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case platformuser.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case platformuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case platformuser.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case platformuser.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case platformuser.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(platformuser.FieldDisplayName) {
		fields = append(fields, platformuser.FieldDisplayName)
	}
	if m.FieldCleared(platformuser.FieldLastLogin) {
		fields = append(fields, platformuser.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformUserMutation) ClearField(name string) error {
	switch name {
	case platformuser.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case platformuser.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown PlatformUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformUserMutation) ResetField(name string) error {
	switch name {
	case platformuser.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case platformuser.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case platformuser.FieldEmail:
		m.ResetEmail()
		return nil
	case platformuser.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case platformuser.FieldIsActive:
		m.ResetIsActive()
		return nil
	case platformuser.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	}
	return fmt.Errorf("unknown PlatformUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user_role_assignments != nil {
		edges = append(edges, platformuser.EdgeUserRoleAssignments)
	}
	if m.federated_identities != nil {
		edges = append(edges, platformuser.EdgeFederatedIdentities)
	}
	if m.created_tokens != nil {
		edges = append(edges, platformuser.EdgeCreatedTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformuser.EdgeUserRoleAssignments:
		ids := make([]ent.Value, 0, len(m.user_role_assignments))
		for id := range m.user_role_assignments {
			ids = append(ids, id)
		}
		return ids
	case platformuser.EdgeFederatedIdentities:
		ids := make([]ent.Value, 0, len(m.federated_identities))
		for id := range m.federated_identities {
			ids = append(ids, id)
		}
		return ids
	case platformuser.EdgeCreatedTokens:
		ids := make([]ent.Value, 0, len(m.created_tokens))
		for id := range m.created_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_role_assignments != nil {
		edges = append(edges, platformuser.EdgeUserRoleAssignments)
	}
	if m.removedfederated_identities != nil {
		edges = append(edges, platformuser.EdgeFederatedIdentities)
	}
	if m.removedcreated_tokens != nil {
		edges = append(edges, platformuser.EdgeCreatedTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platformuser.EdgeUserRoleAssignments:
		ids := make([]ent.Value, 0, len(m.removeduser_role_assignments))
		for id := range m.removeduser_role_assignments {
			ids = append(ids, id)
		}
		return ids
	case platformuser.EdgeFederatedIdentities:
		ids := make([]ent.Value, 0, len(m.removedfederated_identities))
		for id := range m.removedfederated_identities {
			ids = append(ids, id)
		}
		return ids
	case platformuser.EdgeCreatedTokens:
		ids := make([]ent.Value, 0, len(m.removedcreated_tokens))
		for id := range m.removedcreated_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser_role_assignments {
		edges = append(edges, platformuser.EdgeUserRoleAssignments)
	}
	if m.clearedfederated_identities {
		edges = append(edges, platformuser.EdgeFederatedIdentities)
	}
	if m.clearedcreated_tokens {
		edges = append(edges, platformuser.EdgeCreatedTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformUserMutation) EdgeCleared(name string) bool {
	switch name {
	case platformuser.EdgeUserRoleAssignments:
		return m.cleareduser_role_assignments
	case platformuser.EdgeFederatedIdentities:
		return m.clearedfederated_identities
	case platformuser.EdgeCreatedTokens:
		return m.clearedcreated_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformUserMutation) ResetEdge(name string) error {
	switch name {
	case platformuser.EdgeUserRoleAssignments:
		m.ResetUserRoleAssignments()
		return nil
	case platformuser.EdgeFederatedIdentities:
		m.ResetFederatedIdentities()
		return nil
	case platformuser.EdgeCreatedTokens:
		m.ResetCreatedTokens()
		return nil
	}
	return fmt.Errorf("unknown PlatformUser edge %s", name)
}

// PlatformUserRoleAssignmentMutation represents an operation that mutates the PlatformUserRoleAssignment nodes in the graph.
type PlatformUserRoleAssignmentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	update_time   *time.Time
	is_active     *bool
	assigned_at   *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*PlatformUserRoleAssignment, error)
	predicates    []predicate.PlatformUserRoleAssignment
}

var _ ent.Mutation = (*PlatformUserRoleAssignmentMutation)(nil)

// platformuserroleassignmentOption allows management of the mutation configuration using functional options.
type platformuserroleassignmentOption func(*PlatformUserRoleAssignmentMutation)

// newPlatformUserRoleAssignmentMutation creates new mutation for the PlatformUserRoleAssignment entity.
func newPlatformUserRoleAssignmentMutation(c config, op Op, opts ...platformuserroleassignmentOption) *PlatformUserRoleAssignmentMutation {
	m := &PlatformUserRoleAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformUserRoleAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformUserRoleAssignmentID sets the ID field of the mutation.
func withPlatformUserRoleAssignmentID(id int) platformuserroleassignmentOption {
	return func(m *PlatformUserRoleAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformUserRoleAssignment
		)
		m.oldValue = func(ctx context.Context) (*PlatformUserRoleAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformUserRoleAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformUserRoleAssignment sets the old PlatformUserRoleAssignment of the mutation.
func withPlatformUserRoleAssignment(node *PlatformUserRoleAssignment) platformuserroleassignmentOption {
	return func(m *PlatformUserRoleAssignmentMutation) {
		m.oldValue = func(context.Context) (*PlatformUserRoleAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformUserRoleAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformUserRoleAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformUserRoleAssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformUserRoleAssignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformUserRoleAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUpdateTime sets the "update_time" field.
func (m *PlatformUserRoleAssignmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PlatformUserRoleAssignmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PlatformUserRoleAssignment entity.
// If the PlatformUserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserRoleAssignmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PlatformUserRoleAssignmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIsActive sets the "is_active" field.
func (m *PlatformUserRoleAssignmentMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlatformUserRoleAssignmentMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PlatformUserRoleAssignment entity.
// If the PlatformUserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserRoleAssignmentMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlatformUserRoleAssignmentMutation) ResetIsActive() {
	m.is_active = nil
}

// SetAssignedAt sets the "assigned_at" field.
func (m *PlatformUserRoleAssignmentMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *PlatformUserRoleAssignmentMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the PlatformUserRoleAssignment entity.
// If the PlatformUserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformUserRoleAssignmentMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *PlatformUserRoleAssignmentMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetUserID sets the "user" edge to the PlatformUser entity by id.
func (m *PlatformUserRoleAssignmentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the PlatformUser entity.
func (m *PlatformUserRoleAssignmentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the PlatformUser entity was cleared.
func (m *PlatformUserRoleAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PlatformUserRoleAssignmentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PlatformUserRoleAssignmentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PlatformUserRoleAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetRoleID sets the "role" edge to the PlatformAppRole entity by id.
func (m *PlatformUserRoleAssignmentMutation) SetRoleID(id int) {
	m.role = &id
}

// ClearRole clears the "role" edge to the PlatformAppRole entity.
func (m *PlatformUserRoleAssignmentMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the PlatformAppRole entity was cleared.
func (m *PlatformUserRoleAssignmentMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *PlatformUserRoleAssignmentMutation) RoleID() (id int, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *PlatformUserRoleAssignmentMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *PlatformUserRoleAssignmentMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the PlatformUserRoleAssignmentMutation builder.
func (m *PlatformUserRoleAssignmentMutation) Where(ps ...predicate.PlatformUserRoleAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlatformUserRoleAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlatformUserRoleAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlatformUserRoleAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlatformUserRoleAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlatformUserRoleAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlatformUserRoleAssignment).
func (m *PlatformUserRoleAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformUserRoleAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.update_time != nil {
		fields = append(fields, platformuserroleassignment.FieldUpdateTime)
	}
	if m.is_active != nil {
		fields = append(fields, platformuserroleassignment.FieldIsActive)
	}
	if m.assigned_at != nil {
		fields = append(fields, platformuserroleassignment.FieldAssignedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformUserRoleAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformuserroleassignment.FieldUpdateTime:
		return m.UpdateTime()
	case platformuserroleassignment.FieldIsActive:
		return m.IsActive()
	case platformuserroleassignment.FieldAssignedAt:
		return m.AssignedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformUserRoleAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformuserroleassignment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case platformuserroleassignment.FieldIsActive:
		return m.OldIsActive(ctx)
	case platformuserroleassignment.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformUserRoleAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformUserRoleAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformuserroleassignment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case platformuserroleassignment.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case platformuserroleassignment.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformUserRoleAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformUserRoleAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformUserRoleAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformUserRoleAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlatformUserRoleAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformUserRoleAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformUserRoleAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformUserRoleAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlatformUserRoleAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformUserRoleAssignmentMutation) ResetField(name string) error {
	switch name {
	case platformuserroleassignment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case platformuserroleassignment.FieldIsActive:
		m.ResetIsActive()
		return nil
	case platformuserroleassignment.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	}
	return fmt.Errorf("unknown PlatformUserRoleAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformUserRoleAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, platformuserroleassignment.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, platformuserroleassignment.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformUserRoleAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformuserroleassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case platformuserroleassignment.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformUserRoleAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformUserRoleAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformUserRoleAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, platformuserroleassignment.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, platformuserroleassignment.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformUserRoleAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case platformuserroleassignment.EdgeUser:
		return m.cleareduser
	case platformuserroleassignment.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformUserRoleAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case platformuserroleassignment.EdgeUser:
		m.ClearUser()
		return nil
	case platformuserroleassignment.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown PlatformUserRoleAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformUserRoleAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case platformuserroleassignment.EdgeUser:
		m.ResetUser()
		return nil
	case platformuserroleassignment.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown PlatformUserRoleAssignment edge %s", name)
}

// RefreshTokenMutation represents an operation that mutates the RefreshToken nodes in the graph.
type RefreshTokenMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	client_id                 *string
	scopes                    *[]string
	appendscopes              []string
	nonce                     *string
	claims_user_id            *string
	claims_username           *string
	claims_email              *string
	claims_email_verified     *bool
	claims_groups             *[]string
	appendclaims_groups       []string
	claims_preferred_username *string
	connector_id              *string
	connector_data            *[]byte
	token                     *string
	obsolete_token            *string
	created_at                *time.Time
	last_used                 *time.Time
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*RefreshToken, error)
	predicates                []predicate.RefreshToken
}

var _ ent.Mutation = (*RefreshTokenMutation)(nil)

// refreshtokenOption allows management of the mutation configuration using functional options.
type refreshtokenOption func(*RefreshTokenMutation)

// newRefreshTokenMutation creates new mutation for the RefreshToken entity.
func newRefreshTokenMutation(c config, op Op, opts ...refreshtokenOption) *RefreshTokenMutation {
	m := &RefreshTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeRefreshToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefreshTokenID sets the ID field of the mutation.
func withRefreshTokenID(id string) refreshtokenOption {
	return func(m *RefreshTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *RefreshToken
		)
		m.oldValue = func(ctx context.Context) (*RefreshToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RefreshToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRefreshToken sets the old RefreshToken of the mutation.
func withRefreshToken(node *RefreshToken) refreshtokenOption {
	return func(m *RefreshTokenMutation) {
		m.oldValue = func(context.Context) (*RefreshToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefreshTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefreshTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RefreshToken entities.
func (m *RefreshTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefreshTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RefreshTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RefreshToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *RefreshTokenMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *RefreshTokenMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *RefreshTokenMutation) ResetClientID() {
	m.client_id = nil
}

// SetScopes sets the "scopes" field.
func (m *RefreshTokenMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RefreshTokenMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *RefreshTokenMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *RefreshTokenMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *RefreshTokenMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[refreshtoken.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *RefreshTokenMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[refreshtoken.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RefreshTokenMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, refreshtoken.FieldScopes)
}

// SetNonce sets the "nonce" field.
func (m *RefreshTokenMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *RefreshTokenMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *RefreshTokenMutation) ResetNonce() {
	m.nonce = nil
}

// SetClaimsUserID sets the "claims_user_id" field.
func (m *RefreshTokenMutation) SetClaimsUserID(s string) {
	m.claims_user_id = &s
}

// ClaimsUserID returns the value of the "claims_user_id" field in the mutation.
func (m *RefreshTokenMutation) ClaimsUserID() (r string, exists bool) {
	v := m.claims_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUserID returns the old "claims_user_id" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUserID: %w", err)
	}
	return oldValue.ClaimsUserID, nil
}

// ResetClaimsUserID resets all changes to the "claims_user_id" field.
func (m *RefreshTokenMutation) ResetClaimsUserID() {
	m.claims_user_id = nil
}

// SetClaimsUsername sets the "claims_username" field.
func (m *RefreshTokenMutation) SetClaimsUsername(s string) {
	m.claims_username = &s
}

// ClaimsUsername returns the value of the "claims_username" field in the mutation.
func (m *RefreshTokenMutation) ClaimsUsername() (r string, exists bool) {
	v := m.claims_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUsername returns the old "claims_username" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUsername: %w", err)
	}
	return oldValue.ClaimsUsername, nil
}

// ResetClaimsUsername resets all changes to the "claims_username" field.
func (m *RefreshTokenMutation) ResetClaimsUsername() {
	m.claims_username = nil
}

// SetClaimsEmail sets the "claims_email" field.
func (m *RefreshTokenMutation) SetClaimsEmail(s string) {
	m.claims_email = &s
}

// ClaimsEmail returns the value of the "claims_email" field in the mutation.
func (m *RefreshTokenMutation) ClaimsEmail() (r string, exists bool) {
	v := m.claims_email
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmail returns the old "claims_email" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmail: %w", err)
	}
	return oldValue.ClaimsEmail, nil
}

// ResetClaimsEmail resets all changes to the "claims_email" field.
func (m *RefreshTokenMutation) ResetClaimsEmail() {
	m.claims_email = nil
}

// SetClaimsEmailVerified sets the "claims_email_verified" field.
func (m *RefreshTokenMutation) SetClaimsEmailVerified(b bool) {
	m.claims_email_verified = &b
}

// ClaimsEmailVerified returns the value of the "claims_email_verified" field in the mutation.
func (m *RefreshTokenMutation) ClaimsEmailVerified() (r bool, exists bool) {
	v := m.claims_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmailVerified returns the old "claims_email_verified" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmailVerified: %w", err)
	}
	return oldValue.ClaimsEmailVerified, nil
}

// ResetClaimsEmailVerified resets all changes to the "claims_email_verified" field.
func (m *RefreshTokenMutation) ResetClaimsEmailVerified() {
	m.claims_email_verified = nil
}

// SetClaimsGroups sets the "claims_groups" field.
func (m *RefreshTokenMutation) SetClaimsGroups(s []string) {
	m.claims_groups = &s
	m.appendclaims_groups = nil
}

// ClaimsGroups returns the value of the "claims_groups" field in the mutation.
func (m *RefreshTokenMutation) ClaimsGroups() (r []string, exists bool) {
	v := m.claims_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsGroups returns the old "claims_groups" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsGroups: %w", err)
	}
	return oldValue.ClaimsGroups, nil
}

// AppendClaimsGroups adds s to the "claims_groups" field.
func (m *RefreshTokenMutation) AppendClaimsGroups(s []string) {
	m.appendclaims_groups = append(m.appendclaims_groups, s...)
}

// AppendedClaimsGroups returns the list of values that were appended to the "claims_groups" field in this mutation.
func (m *RefreshTokenMutation) AppendedClaimsGroups() ([]string, bool) {
	if len(m.appendclaims_groups) == 0 {
		return nil, false
	}
	return m.appendclaims_groups, true
}

// ClearClaimsGroups clears the value of the "claims_groups" field.
func (m *RefreshTokenMutation) ClearClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	m.clearedFields[refreshtoken.FieldClaimsGroups] = struct{}{}
}

// ClaimsGroupsCleared returns if the "claims_groups" field was cleared in this mutation.
func (m *RefreshTokenMutation) ClaimsGroupsCleared() bool {
	_, ok := m.clearedFields[refreshtoken.FieldClaimsGroups]
	return ok
}

// ResetClaimsGroups resets all changes to the "claims_groups" field.
func (m *RefreshTokenMutation) ResetClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	delete(m.clearedFields, refreshtoken.FieldClaimsGroups)
}

// SetClaimsPreferredUsername sets the "claims_preferred_username" field.
func (m *RefreshTokenMutation) SetClaimsPreferredUsername(s string) {
	m.claims_preferred_username = &s
}

// ClaimsPreferredUsername returns the value of the "claims_preferred_username" field in the mutation.
func (m *RefreshTokenMutation) ClaimsPreferredUsername() (r string, exists bool) {
	v := m.claims_preferred_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsPreferredUsername returns the old "claims_preferred_username" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsPreferredUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsPreferredUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsPreferredUsername: %w", err)
	}
	return oldValue.ClaimsPreferredUsername, nil
}

// ResetClaimsPreferredUsername resets all changes to the "claims_preferred_username" field.
func (m *RefreshTokenMutation) ResetClaimsPreferredUsername() {
	m.claims_preferred_username = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *RefreshTokenMutation) SetConnectorID(s string) {
	m.connector_id = &s
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *RefreshTokenMutation) ConnectorID() (r string, exists bool) {
	v := m.connector_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldConnectorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *RefreshTokenMutation) ResetConnectorID() {
	m.connector_id = nil
}

// SetConnectorData sets the "connector_data" field.
func (m *RefreshTokenMutation) SetConnectorData(b []byte) {
	m.connector_data = &b
}

// ConnectorData returns the value of the "connector_data" field in the mutation.
func (m *RefreshTokenMutation) ConnectorData() (r []byte, exists bool) {
	v := m.connector_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorData returns the old "connector_data" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorData: %w", err)
	}
	return oldValue.ConnectorData, nil
}

// ClearConnectorData clears the value of the "connector_data" field.
func (m *RefreshTokenMutation) ClearConnectorData() {
	m.connector_data = nil
	m.clearedFields[refreshtoken.FieldConnectorData] = struct{}{}
}

// ConnectorDataCleared returns if the "connector_data" field was cleared in this mutation.
func (m *RefreshTokenMutation) ConnectorDataCleared() bool {
	_, ok := m.clearedFields[refreshtoken.FieldConnectorData]
	return ok
}

// ResetConnectorData resets all changes to the "connector_data" field.
func (m *RefreshTokenMutation) ResetConnectorData() {
	m.connector_data = nil
	delete(m.clearedFields, refreshtoken.FieldConnectorData)
}

// SetToken sets the "token" field.
func (m *RefreshTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *RefreshTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *RefreshTokenMutation) ResetToken() {
	m.token = nil
}

// SetObsoleteToken sets the "obsolete_token" field.
func (m *RefreshTokenMutation) SetObsoleteToken(s string) {
	m.obsolete_token = &s
}

// ObsoleteToken returns the value of the "obsolete_token" field in the mutation.
func (m *RefreshTokenMutation) ObsoleteToken() (r string, exists bool) {
	v := m.obsolete_token
	if v == nil {
		return
	}
	return *v, true
}

// OldObsoleteToken returns the old "obsolete_token" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldObsoleteToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObsoleteToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObsoleteToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObsoleteToken: %w", err)
	}
	return oldValue.ObsoleteToken, nil
}

// ResetObsoleteToken resets all changes to the "obsolete_token" field.
func (m *RefreshTokenMutation) ResetObsoleteToken() {
	m.obsolete_token = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RefreshTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RefreshTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RefreshTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastUsed sets the "last_used" field.
func (m *RefreshTokenMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *RefreshTokenMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the RefreshToken entity.
// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokenMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *RefreshTokenMutation) ResetLastUsed() {
	m.last_used = nil
}

// Where appends a list predicates to the RefreshTokenMutation builder.
func (m *RefreshTokenMutation) Where(ps ...predicate.RefreshToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RefreshTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RefreshTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RefreshToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RefreshTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RefreshTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RefreshToken).
func (m *RefreshTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefreshTokenMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.client_id != nil {
		fields = append(fields, refreshtoken.FieldClientID)
	}
	if m.scopes != nil {
		fields = append(fields, refreshtoken.FieldScopes)
	}
	if m.nonce != nil {
		fields = append(fields, refreshtoken.FieldNonce)
	}
	if m.claims_user_id != nil {
		fields = append(fields, refreshtoken.FieldClaimsUserID)
	}
	if m.claims_username != nil {
		fields = append(fields, refreshtoken.FieldClaimsUsername)
	}
	if m.claims_email != nil {
		fields = append(fields, refreshtoken.FieldClaimsEmail)
	}
	if m.claims_email_verified != nil {
		fields = append(fields, refreshtoken.FieldClaimsEmailVerified)
	}
	if m.claims_groups != nil {
		fields = append(fields, refreshtoken.FieldClaimsGroups)
	}
	if m.claims_preferred_username != nil {
		fields = append(fields, refreshtoken.FieldClaimsPreferredUsername)
	}
	if m.connector_id != nil {
		fields = append(fields, refreshtoken.FieldConnectorID)
	}
	if m.connector_data != nil {
		fields = append(fields, refreshtoken.FieldConnectorData)
	}
	if m.token != nil {
		fields = append(fields, refreshtoken.FieldToken)
	}
	if m.obsolete_token != nil {
		fields = append(fields, refreshtoken.FieldObsoleteToken)
	}
	if m.created_at != nil {
		fields = append(fields, refreshtoken.FieldCreatedAt)
	}
	if m.last_used != nil {
		fields = append(fields, refreshtoken.FieldLastUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefreshTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case refreshtoken.FieldClientID:
		return m.ClientID()
	case refreshtoken.FieldScopes:
		return m.Scopes()
	case refreshtoken.FieldNonce:
		return m.Nonce()
	case refreshtoken.FieldClaimsUserID:
		return m.ClaimsUserID()
	case refreshtoken.FieldClaimsUsername:
		return m.ClaimsUsername()
	case refreshtoken.FieldClaimsEmail:
		return m.ClaimsEmail()
	case refreshtoken.FieldClaimsEmailVerified:
		return m.ClaimsEmailVerified()
	case refreshtoken.FieldClaimsGroups:
		return m.ClaimsGroups()
	case refreshtoken.FieldClaimsPreferredUsername:
		return m.ClaimsPreferredUsername()
	case refreshtoken.FieldConnectorID:
		return m.ConnectorID()
	case refreshtoken.FieldConnectorData:
		return m.ConnectorData()
	case refreshtoken.FieldToken:
		return m.Token()
	case refreshtoken.FieldObsoleteToken:
		return m.ObsoleteToken()
	case refreshtoken.FieldCreatedAt:
		return m.CreatedAt()
	case refreshtoken.FieldLastUsed:
		return m.LastUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefreshTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case refreshtoken.FieldClientID:
		return m.OldClientID(ctx)
	case refreshtoken.FieldScopes:
		return m.OldScopes(ctx)
	case refreshtoken.FieldNonce:
		return m.OldNonce(ctx)
	case refreshtoken.FieldClaimsUserID:
		return m.OldClaimsUserID(ctx)
	case refreshtoken.FieldClaimsUsername:
		return m.OldClaimsUsername(ctx)
	case refreshtoken.FieldClaimsEmail:
		return m.OldClaimsEmail(ctx)
	case refreshtoken.FieldClaimsEmailVerified:
		return m.OldClaimsEmailVerified(ctx)
	case refreshtoken.FieldClaimsGroups:
		return m.OldClaimsGroups(ctx)
	case refreshtoken.FieldClaimsPreferredUsername:
		return m.OldClaimsPreferredUsername(ctx)
	case refreshtoken.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case refreshtoken.FieldConnectorData:
		return m.OldConnectorData(ctx)
	case refreshtoken.FieldToken:
		return m.OldToken(ctx)
	case refreshtoken.FieldObsoleteToken:
		return m.OldObsoleteToken(ctx)
	case refreshtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case refreshtoken.FieldLastUsed:
		return m.OldLastUsed(ctx)
	}
	return nil, fmt.Errorf("unknown RefreshToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case refreshtoken.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case refreshtoken.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case refreshtoken.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case refreshtoken.FieldClaimsUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUserID(v)
		return nil
	case refreshtoken.FieldClaimsUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUsername(v)
		return nil
	case refreshtoken.FieldClaimsEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmail(v)
		return nil
	case refreshtoken.FieldClaimsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmailVerified(v)
		return nil
	case refreshtoken.FieldClaimsGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsGroups(v)
		return nil
	case refreshtoken.FieldClaimsPreferredUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsPreferredUsername(v)
		return nil
	case refreshtoken.FieldConnectorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case refreshtoken.FieldConnectorData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorData(v)
		return nil
	case refreshtoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case refreshtoken.FieldObsoleteToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObsoleteToken(v)
		return nil
	case refreshtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case refreshtoken.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	}
	return fmt.Errorf("unknown RefreshToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefreshTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefreshTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RefreshToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefreshTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(refreshtoken.FieldScopes) {
		fields = append(fields, refreshtoken.FieldScopes)
	}
	if m.FieldCleared(refreshtoken.FieldClaimsGroups) {
		fields = append(fields, refreshtoken.FieldClaimsGroups)
	}
	if m.FieldCleared(refreshtoken.FieldConnectorData) {
		fields = append(fields, refreshtoken.FieldConnectorData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefreshTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefreshTokenMutation) ClearField(name string) error {
	switch name {
	case refreshtoken.FieldScopes:
		m.ClearScopes()
		return nil
	case refreshtoken.FieldClaimsGroups:
		m.ClearClaimsGroups()
		return nil
	case refreshtoken.FieldConnectorData:
		m.ClearConnectorData()
		return nil
	}
	return fmt.Errorf("unknown RefreshToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefreshTokenMutation) ResetField(name string) error {
	switch name {
	case refreshtoken.FieldClientID:
		m.ResetClientID()
		return nil
	case refreshtoken.FieldScopes:
		m.ResetScopes()
		return nil
	case refreshtoken.FieldNonce:
		m.ResetNonce()
		return nil
	case refreshtoken.FieldClaimsUserID:
		m.ResetClaimsUserID()
		return nil
	case refreshtoken.FieldClaimsUsername:
		m.ResetClaimsUsername()
		return nil
	case refreshtoken.FieldClaimsEmail:
		m.ResetClaimsEmail()
		return nil
	case refreshtoken.FieldClaimsEmailVerified:
		m.ResetClaimsEmailVerified()
		return nil
	case refreshtoken.FieldClaimsGroups:
		m.ResetClaimsGroups()
		return nil
	case refreshtoken.FieldClaimsPreferredUsername:
		m.ResetClaimsPreferredUsername()
		return nil
	case refreshtoken.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case refreshtoken.FieldConnectorData:
		m.ResetConnectorData()
		return nil
	case refreshtoken.FieldToken:
		m.ResetToken()
		return nil
	case refreshtoken.FieldObsoleteToken:
		m.ResetObsoleteToken()
		return nil
	case refreshtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case refreshtoken.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	}
	return fmt.Errorf("unknown RefreshToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefreshTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefreshTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefreshTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefreshTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefreshTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefreshTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefreshTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RefreshToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefreshTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RefreshToken edge %s", name)
}
